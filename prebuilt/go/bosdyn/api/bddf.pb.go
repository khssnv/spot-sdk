// Copyright (c) 2021 Boston Dynamics, Inc.  All rights reserved.
//
// Downloading, reproducing, distributing or otherwise using the SDK Software
// is subject to the terms and conditions of the Boston Dynamics Software
// Development Kit License (20191101-BDSDK-SL).

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.27.1
// 	protoc        v3.17.3
// source: bosdyn/api/bddf.proto

package api

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	reflect "reflect"
	sync "sync"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// "Plain old data" types which may be stored within POD data blocks.
type PodTypeEnum int32

const (
	PodTypeEnum_TYPE_UNSPECIFIED PodTypeEnum = 0
	PodTypeEnum_TYPE_INT8        PodTypeEnum = 1
	PodTypeEnum_TYPE_INT16       PodTypeEnum = 2
	PodTypeEnum_TYPE_INT32       PodTypeEnum = 3
	PodTypeEnum_TYPE_INT64       PodTypeEnum = 4
	PodTypeEnum_TYPE_UINT8       PodTypeEnum = 5
	PodTypeEnum_TYPE_UINT16      PodTypeEnum = 6
	PodTypeEnum_TYPE_UINT32      PodTypeEnum = 7
	PodTypeEnum_TYPE_UINT64      PodTypeEnum = 8
	PodTypeEnum_TYPE_FLOAT32     PodTypeEnum = 9
	PodTypeEnum_TYPE_FLOAT64     PodTypeEnum = 10
)

// Enum value maps for PodTypeEnum.
var (
	PodTypeEnum_name = map[int32]string{
		0:  "TYPE_UNSPECIFIED",
		1:  "TYPE_INT8",
		2:  "TYPE_INT16",
		3:  "TYPE_INT32",
		4:  "TYPE_INT64",
		5:  "TYPE_UINT8",
		6:  "TYPE_UINT16",
		7:  "TYPE_UINT32",
		8:  "TYPE_UINT64",
		9:  "TYPE_FLOAT32",
		10: "TYPE_FLOAT64",
	}
	PodTypeEnum_value = map[string]int32{
		"TYPE_UNSPECIFIED": 0,
		"TYPE_INT8":        1,
		"TYPE_INT16":       2,
		"TYPE_INT32":       3,
		"TYPE_INT64":       4,
		"TYPE_UINT8":       5,
		"TYPE_UINT16":      6,
		"TYPE_UINT32":      7,
		"TYPE_UINT64":      8,
		"TYPE_FLOAT32":     9,
		"TYPE_FLOAT64":     10,
	}
)

func (x PodTypeEnum) Enum() *PodTypeEnum {
	p := new(PodTypeEnum)
	*p = x
	return p
}

func (x PodTypeEnum) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (PodTypeEnum) Descriptor() protoreflect.EnumDescriptor {
	return file_bosdyn_api_bddf_proto_enumTypes[0].Descriptor()
}

func (PodTypeEnum) Type() protoreflect.EnumType {
	return &file_bosdyn_api_bddf_proto_enumTypes[0]
}

func (x PodTypeEnum) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use PodTypeEnum.Descriptor instead.
func (PodTypeEnum) EnumDescriptor() ([]byte, []int) {
	return file_bosdyn_api_bddf_proto_rawDescGZIP(), []int{0}
}

type FileFormatDescriptor_CheckSumType int32

const (
	// Checksum type is unspecified.  Should not be used.
	FileFormatDescriptor_CHECKSUM_TYPE_UNKNOWN FileFormatDescriptor_CheckSumType = 0
	// The writer of this stream is not computing a checksum.
	// The stream checksum at the end of the file will be 160 bits all set to 0.
	FileFormatDescriptor_CHECKSUM_TYPE_NONE FileFormatDescriptor_CheckSumType = 1
	// A 160 bit SHA1 checksum will be included at the end of the stream.
	// This checksum will be computed over all data before digest itself at the
	//  end of the stream, and can be used to verify the stream was received uncorrupted.
	FileFormatDescriptor_CHECKSUM_TYPE_SHA1 FileFormatDescriptor_CheckSumType = 2
)

// Enum value maps for FileFormatDescriptor_CheckSumType.
var (
	FileFormatDescriptor_CheckSumType_name = map[int32]string{
		0: "CHECKSUM_TYPE_UNKNOWN",
		1: "CHECKSUM_TYPE_NONE",
		2: "CHECKSUM_TYPE_SHA1",
	}
	FileFormatDescriptor_CheckSumType_value = map[string]int32{
		"CHECKSUM_TYPE_UNKNOWN": 0,
		"CHECKSUM_TYPE_NONE":    1,
		"CHECKSUM_TYPE_SHA1":    2,
	}
)

func (x FileFormatDescriptor_CheckSumType) Enum() *FileFormatDescriptor_CheckSumType {
	p := new(FileFormatDescriptor_CheckSumType)
	*p = x
	return p
}

func (x FileFormatDescriptor_CheckSumType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (FileFormatDescriptor_CheckSumType) Descriptor() protoreflect.EnumDescriptor {
	return file_bosdyn_api_bddf_proto_enumTypes[1].Descriptor()
}

func (FileFormatDescriptor_CheckSumType) Type() protoreflect.EnumType {
	return &file_bosdyn_api_bddf_proto_enumTypes[1]
}

func (x FileFormatDescriptor_CheckSumType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use FileFormatDescriptor_CheckSumType.Descriptor instead.
func (FileFormatDescriptor_CheckSumType) EnumDescriptor() ([]byte, []int) {
	return file_bosdyn_api_bddf_proto_rawDescGZIP(), []int{2, 0}
}

// A Descriptor block typically describes a series of messages, but the descriptor at the
//  start of the file describes the contents of the file as a whole, and the descriptor
//  at the end of the file is an index structure to allow efficient access to the contents
//  of the file.
type DescriptorBlock struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Types that are assignable to DescriptorType:
	//	*DescriptorBlock_FileDescriptor
	//	*DescriptorBlock_SeriesDescriptor
	//	*DescriptorBlock_SeriesBlockIndex
	//	*DescriptorBlock_FileIndex
	DescriptorType isDescriptorBlock_DescriptorType `protobuf_oneof:"DescriptorType"`
}

func (x *DescriptorBlock) Reset() {
	*x = DescriptorBlock{}
	if protoimpl.UnsafeEnabled {
		mi := &file_bosdyn_api_bddf_proto_msgTypes[0]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *DescriptorBlock) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DescriptorBlock) ProtoMessage() {}

func (x *DescriptorBlock) ProtoReflect() protoreflect.Message {
	mi := &file_bosdyn_api_bddf_proto_msgTypes[0]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DescriptorBlock.ProtoReflect.Descriptor instead.
func (*DescriptorBlock) Descriptor() ([]byte, []int) {
	return file_bosdyn_api_bddf_proto_rawDescGZIP(), []int{0}
}

func (m *DescriptorBlock) GetDescriptorType() isDescriptorBlock_DescriptorType {
	if m != nil {
		return m.DescriptorType
	}
	return nil
}

func (x *DescriptorBlock) GetFileDescriptor() *FileFormatDescriptor {
	if x, ok := x.GetDescriptorType().(*DescriptorBlock_FileDescriptor); ok {
		return x.FileDescriptor
	}
	return nil
}

func (x *DescriptorBlock) GetSeriesDescriptor() *SeriesDescriptor {
	if x, ok := x.GetDescriptorType().(*DescriptorBlock_SeriesDescriptor); ok {
		return x.SeriesDescriptor
	}
	return nil
}

func (x *DescriptorBlock) GetSeriesBlockIndex() *SeriesBlockIndex {
	if x, ok := x.GetDescriptorType().(*DescriptorBlock_SeriesBlockIndex); ok {
		return x.SeriesBlockIndex
	}
	return nil
}

func (x *DescriptorBlock) GetFileIndex() *FileIndex {
	if x, ok := x.GetDescriptorType().(*DescriptorBlock_FileIndex); ok {
		return x.FileIndex
	}
	return nil
}

type isDescriptorBlock_DescriptorType interface {
	isDescriptorBlock_DescriptorType()
}

type DescriptorBlock_FileDescriptor struct {
	FileDescriptor *FileFormatDescriptor `protobuf:"bytes,1,opt,name=file_descriptor,json=fileDescriptor,proto3,oneof"`
}

type DescriptorBlock_SeriesDescriptor struct {
	SeriesDescriptor *SeriesDescriptor `protobuf:"bytes,2,opt,name=series_descriptor,json=seriesDescriptor,proto3,oneof"`
}

type DescriptorBlock_SeriesBlockIndex struct {
	SeriesBlockIndex *SeriesBlockIndex `protobuf:"bytes,3,opt,name=series_block_index,json=seriesBlockIndex,proto3,oneof"`
}

type DescriptorBlock_FileIndex struct {
	FileIndex *FileIndex `protobuf:"bytes,4,opt,name=file_index,json=fileIndex,proto3,oneof"`
}

func (*DescriptorBlock_FileDescriptor) isDescriptorBlock_DescriptorType() {}

func (*DescriptorBlock_SeriesDescriptor) isDescriptorBlock_DescriptorType() {}

func (*DescriptorBlock_SeriesBlockIndex) isDescriptorBlock_DescriptorType() {}

func (*DescriptorBlock_FileIndex) isDescriptorBlock_DescriptorType() {}

// A DataDescriptor describes a data block which immediately follows it in the file.
// A corresponding SeriesDescriptor with a matching series_index must precede this in the file.
type DataDescriptor struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The series_index references the SeriesDescriptor to which the data following is associated.
	SeriesIndex uint32 `protobuf:"varint,1,opt,name=series_index,json=seriesIndex,proto3" json:"series_index,omitempty"`
	// The time at which the data is considered to be captured/sampled.
	// E.g., the shutter-close time of a captured image.
	Timestamp *timestamppb.Timestamp `protobuf:"bytes,2,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	// Sometimes a visualizer will want to organize message by data timestamp, sometimes by
	//  the time messages were published or logged.
	// The additional_indexes field allows extra indexes or timestamps to be associated with
	//  each data block for this purpose.
	// Other identifying information may also be used here, such as the PID of the process which
	//  originated the data (e.g., for detecting if and when that process restarted).
	// The values in this field should correspond to the labels defined in "additional_index_names"
	//  in the corresponding SeriesDescriptor.
	AdditionalIndexes []int64 `protobuf:"varint,3,rep,packed,name=additional_indexes,json=additionalIndexes,proto3" json:"additional_indexes,omitempty"`
}

func (x *DataDescriptor) Reset() {
	*x = DataDescriptor{}
	if protoimpl.UnsafeEnabled {
		mi := &file_bosdyn_api_bddf_proto_msgTypes[1]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *DataDescriptor) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DataDescriptor) ProtoMessage() {}

func (x *DataDescriptor) ProtoReflect() protoreflect.Message {
	mi := &file_bosdyn_api_bddf_proto_msgTypes[1]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DataDescriptor.ProtoReflect.Descriptor instead.
func (*DataDescriptor) Descriptor() ([]byte, []int) {
	return file_bosdyn_api_bddf_proto_rawDescGZIP(), []int{1}
}

func (x *DataDescriptor) GetSeriesIndex() uint32 {
	if x != nil {
		return x.SeriesIndex
	}
	return 0
}

func (x *DataDescriptor) GetTimestamp() *timestamppb.Timestamp {
	if x != nil {
		return x.Timestamp
	}
	return nil
}

func (x *DataDescriptor) GetAdditionalIndexes() []int64 {
	if x != nil {
		return x.AdditionalIndexes
	}
	return nil
}

// The first block in the file should be a DescriptorBlock containing a FileFormatDescriptor.
// FileFormatDescriptor indicates the file format version and annotations.
// Annotations describe things like the robot from which the log was taken and the release id.
// The format of annotation keys should be
//   {project-or-organization}/{annotation-name}
// For example, 'bosdyn/robot-serial-number'.
type FileFormatDescriptor struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The version number of the BDDF file.
	Version *FileFormatVersion `protobuf:"bytes,1,opt,name=version,proto3" json:"version,omitempty"`
	// File/stream-wide annotations to describe the content of the file.
	Annotations map[string]string `protobuf:"bytes,2,rep,name=annotations,proto3" json:"annotations,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// The type of checksum supported by this stream.
	// For BDDF version 1.0.0 this should be SHA1.
	ChecksumType FileFormatDescriptor_CheckSumType `protobuf:"varint,3,opt,name=checksum_type,json=checksumType,proto3,enum=bosdyn.api.FileFormatDescriptor_CheckSumType" json:"checksum_type,omitempty"`
	// The number of bytes used for the BDDF checksum.
	// For BDDF version 1.0.0 this should always be 20, even if CHECKSUM_NONE is used.
	ChecksumNumBytes uint32 `protobuf:"varint,4,opt,name=checksum_num_bytes,json=checksumNumBytes,proto3" json:"checksum_num_bytes,omitempty"`
}

func (x *FileFormatDescriptor) Reset() {
	*x = FileFormatDescriptor{}
	if protoimpl.UnsafeEnabled {
		mi := &file_bosdyn_api_bddf_proto_msgTypes[2]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *FileFormatDescriptor) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FileFormatDescriptor) ProtoMessage() {}

func (x *FileFormatDescriptor) ProtoReflect() protoreflect.Message {
	mi := &file_bosdyn_api_bddf_proto_msgTypes[2]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FileFormatDescriptor.ProtoReflect.Descriptor instead.
func (*FileFormatDescriptor) Descriptor() ([]byte, []int) {
	return file_bosdyn_api_bddf_proto_rawDescGZIP(), []int{2}
}

func (x *FileFormatDescriptor) GetVersion() *FileFormatVersion {
	if x != nil {
		return x.Version
	}
	return nil
}

func (x *FileFormatDescriptor) GetAnnotations() map[string]string {
	if x != nil {
		return x.Annotations
	}
	return nil
}

func (x *FileFormatDescriptor) GetChecksumType() FileFormatDescriptor_CheckSumType {
	if x != nil {
		return x.ChecksumType
	}
	return FileFormatDescriptor_CHECKSUM_TYPE_UNKNOWN
}

func (x *FileFormatDescriptor) GetChecksumNumBytes() uint32 {
	if x != nil {
		return x.ChecksumNumBytes
	}
	return 0
}

// The current data file format is 1.0.0.
type FileFormatVersion struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	MajorVersion uint32 `protobuf:"varint,1,opt,name=major_version,json=majorVersion,proto3" json:"major_version,omitempty"`
	MinorVersion uint32 `protobuf:"varint,2,opt,name=minor_version,json=minorVersion,proto3" json:"minor_version,omitempty"`
	PatchLevel   uint32 `protobuf:"varint,3,opt,name=patch_level,json=patchLevel,proto3" json:"patch_level,omitempty"`
}

func (x *FileFormatVersion) Reset() {
	*x = FileFormatVersion{}
	if protoimpl.UnsafeEnabled {
		mi := &file_bosdyn_api_bddf_proto_msgTypes[3]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *FileFormatVersion) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FileFormatVersion) ProtoMessage() {}

func (x *FileFormatVersion) ProtoReflect() protoreflect.Message {
	mi := &file_bosdyn_api_bddf_proto_msgTypes[3]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FileFormatVersion.ProtoReflect.Descriptor instead.
func (*FileFormatVersion) Descriptor() ([]byte, []int) {
	return file_bosdyn_api_bddf_proto_rawDescGZIP(), []int{3}
}

func (x *FileFormatVersion) GetMajorVersion() uint32 {
	if x != nil {
		return x.MajorVersion
	}
	return 0
}

func (x *FileFormatVersion) GetMinorVersion() uint32 {
	if x != nil {
		return x.MinorVersion
	}
	return 0
}

func (x *FileFormatVersion) GetPatchLevel() uint32 {
	if x != nil {
		return x.PatchLevel
	}
	return 0
}

// A description of a series of data blocks.
// These data blocks may either represent binary messages of a variable size, or they may
//  represent a sequence of samples of POD data samples: single/vector/matrix/... of integer
//  or floating-point values.
type SeriesDescriptor struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// This index for the series is unique within the data file.
	SeriesIndex uint32 `protobuf:"varint,1,opt,name=series_index,json=seriesIndex,proto3" json:"series_index,omitempty"`
	// This is the globally unique {key -> value} mapping to identify the series.
	SeriesIdentifier *SeriesIdentifier `protobuf:"bytes,2,opt,name=series_identifier,json=seriesIdentifier,proto3" json:"series_identifier,omitempty"`
	// This is a hash of the series_identifier.
	// The hash is the first 64 bits (read as a big-endian encoded uint64_t) of
	//  SHA1(S K1 V1 K2 V2 ...) where,
	//   - S is series identifier text,
	//   - K1 and V1 are the key and value of the first key and value of the `spec`,
	//   - K2 and V2 are the second key and value of the spec, etc...
	// Here, all strings are encoded as utf-8, and keys are sorted lexicographically using this
	//  encoding (K1 < K2 < ...).
	IdentifierHash uint64 `protobuf:"varint,3,opt,name=identifier_hash,json=identifierHash,proto3" json:"identifier_hash,omitempty"`
	// Types that are assignable to DataType:
	//	*SeriesDescriptor_MessageType
	//	*SeriesDescriptor_PodType
	//	*SeriesDescriptor_StructType
	DataType isSeriesDescriptor_DataType `protobuf_oneof:"DataType"`
	// Annotations are a {key -> value} mapping for associating additional information with
	//  the series.
	// The format of annotation keys should be
	//   {project-or-organization}/{annotation-name}
	// For example, 'bosdyn/channel-name', 'bosdyn/protobuf-type'.
	// Annotation keys without a '/' are reserved.
	// The only current key in the reserved namespace is 'units': e.g., {'units': 'm/s2'}.
	Annotations map[string]string `protobuf:"bytes,7,rep,name=annotations,proto3" json:"annotations,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Labels for additional index values which should be attached to each DataDescriptor
	//  in the series.
	// See the description of "additional_indexes" in DataDescriptor.
	AdditionalIndexNames []string `protobuf:"bytes,8,rep,name=additional_index_names,json=additionalIndexNames,proto3" json:"additional_index_names,omitempty"`
	Description          string   `protobuf:"bytes,9,opt,name=description,proto3" json:"description,omitempty"`
}

func (x *SeriesDescriptor) Reset() {
	*x = SeriesDescriptor{}
	if protoimpl.UnsafeEnabled {
		mi := &file_bosdyn_api_bddf_proto_msgTypes[4]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SeriesDescriptor) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SeriesDescriptor) ProtoMessage() {}

func (x *SeriesDescriptor) ProtoReflect() protoreflect.Message {
	mi := &file_bosdyn_api_bddf_proto_msgTypes[4]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SeriesDescriptor.ProtoReflect.Descriptor instead.
func (*SeriesDescriptor) Descriptor() ([]byte, []int) {
	return file_bosdyn_api_bddf_proto_rawDescGZIP(), []int{4}
}

func (x *SeriesDescriptor) GetSeriesIndex() uint32 {
	if x != nil {
		return x.SeriesIndex
	}
	return 0
}

func (x *SeriesDescriptor) GetSeriesIdentifier() *SeriesIdentifier {
	if x != nil {
		return x.SeriesIdentifier
	}
	return nil
}

func (x *SeriesDescriptor) GetIdentifierHash() uint64 {
	if x != nil {
		return x.IdentifierHash
	}
	return 0
}

func (m *SeriesDescriptor) GetDataType() isSeriesDescriptor_DataType {
	if m != nil {
		return m.DataType
	}
	return nil
}

func (x *SeriesDescriptor) GetMessageType() *MessageTypeDescriptor {
	if x, ok := x.GetDataType().(*SeriesDescriptor_MessageType); ok {
		return x.MessageType
	}
	return nil
}

func (x *SeriesDescriptor) GetPodType() *PodTypeDescriptor {
	if x, ok := x.GetDataType().(*SeriesDescriptor_PodType); ok {
		return x.PodType
	}
	return nil
}

func (x *SeriesDescriptor) GetStructType() *StructTypeDescriptor {
	if x, ok := x.GetDataType().(*SeriesDescriptor_StructType); ok {
		return x.StructType
	}
	return nil
}

func (x *SeriesDescriptor) GetAnnotations() map[string]string {
	if x != nil {
		return x.Annotations
	}
	return nil
}

func (x *SeriesDescriptor) GetAdditionalIndexNames() []string {
	if x != nil {
		return x.AdditionalIndexNames
	}
	return nil
}

func (x *SeriesDescriptor) GetDescription() string {
	if x != nil {
		return x.Description
	}
	return ""
}

type isSeriesDescriptor_DataType interface {
	isSeriesDescriptor_DataType()
}

type SeriesDescriptor_MessageType struct {
	MessageType *MessageTypeDescriptor `protobuf:"bytes,4,opt,name=message_type,json=messageType,proto3,oneof"`
}

type SeriesDescriptor_PodType struct {
	PodType *PodTypeDescriptor `protobuf:"bytes,5,opt,name=pod_type,json=podType,proto3,oneof"`
}

type SeriesDescriptor_StructType struct {
	StructType *StructTypeDescriptor `protobuf:"bytes,6,opt,name=struct_type,json=structType,proto3,oneof"`
}

func (*SeriesDescriptor_MessageType) isSeriesDescriptor_DataType() {}

func (*SeriesDescriptor_PodType) isSeriesDescriptor_DataType() {}

func (*SeriesDescriptor_StructType) isSeriesDescriptor_DataType() {}

// If a data series contains a sequence of binary messages, the encoding and format of these
//  messages is described by a MesssageTypeDescriptor.
type MessageTypeDescriptor struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Description of the content type.
	// E.g., "application/protobuf", "image/jpeg", "text/csv", ...
	ContentType string `protobuf:"bytes,1,opt,name=content_type,json=contentType,proto3" json:"content_type,omitempty"`
	// If content_type is "application/protobuf", this is the full-name of the protobuf type.
	TypeName string `protobuf:"bytes,2,opt,name=type_name,json=typeName,proto3" json:"type_name,omitempty"`
	// If true, message contents are necessary for interpreting other messages.
	// If the content of this file is split into multiple output files, these messages should be
	//  copied into each.
	IsMetadata bool `protobuf:"varint,3,opt,name=is_metadata,json=isMetadata,proto3" json:"is_metadata,omitempty"`
}

func (x *MessageTypeDescriptor) Reset() {
	*x = MessageTypeDescriptor{}
	if protoimpl.UnsafeEnabled {
		mi := &file_bosdyn_api_bddf_proto_msgTypes[5]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *MessageTypeDescriptor) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MessageTypeDescriptor) ProtoMessage() {}

func (x *MessageTypeDescriptor) ProtoReflect() protoreflect.Message {
	mi := &file_bosdyn_api_bddf_proto_msgTypes[5]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MessageTypeDescriptor.ProtoReflect.Descriptor instead.
func (*MessageTypeDescriptor) Descriptor() ([]byte, []int) {
	return file_bosdyn_api_bddf_proto_rawDescGZIP(), []int{5}
}

func (x *MessageTypeDescriptor) GetContentType() string {
	if x != nil {
		return x.ContentType
	}
	return ""
}

func (x *MessageTypeDescriptor) GetTypeName() string {
	if x != nil {
		return x.TypeName
	}
	return ""
}

func (x *MessageTypeDescriptor) GetIsMetadata() bool {
	if x != nil {
		return x.IsMetadata
	}
	return false
}

// If a data series contains signals-style data of time-sampled "plain old datatypes", this
//  describes the content of the series.
// All POD data stored in data blocks is stored in little-endian byte order.
// Any number of samples may be stored within a given data block.
type PodTypeDescriptor struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The type of machine-readable values stored.
	PodType PodTypeEnum `protobuf:"varint,1,opt,name=pod_type,json=podType,proto3,enum=bosdyn.api.PodTypeEnum" json:"pod_type,omitempty"`
	// If empty, indicates a single POD per sample.
	// If one-element, indicates a vector of the given size per sample.
	// If two-elements, indicates a matrix of the given size, and so on.
	// An M x N x .. x P array of data is traversed from innermost (P) to outermost (M) dimension.
	Dimension []uint32 `protobuf:"varint,2,rep,packed,name=dimension,proto3" json:"dimension,omitempty"`
}

func (x *PodTypeDescriptor) Reset() {
	*x = PodTypeDescriptor{}
	if protoimpl.UnsafeEnabled {
		mi := &file_bosdyn_api_bddf_proto_msgTypes[6]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *PodTypeDescriptor) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PodTypeDescriptor) ProtoMessage() {}

func (x *PodTypeDescriptor) ProtoReflect() protoreflect.Message {
	mi := &file_bosdyn_api_bddf_proto_msgTypes[6]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PodTypeDescriptor.ProtoReflect.Descriptor instead.
func (*PodTypeDescriptor) Descriptor() ([]byte, []int) {
	return file_bosdyn_api_bddf_proto_rawDescGZIP(), []int{6}
}

func (x *PodTypeDescriptor) GetPodType() PodTypeEnum {
	if x != nil {
		return x.PodType
	}
	return PodTypeEnum_TYPE_UNSPECIFIED
}

func (x *PodTypeDescriptor) GetDimension() []uint32 {
	if x != nil {
		return x.Dimension
	}
	return nil
}

// A struct series is a composite formed by a set of other series whose messages or signals-ticks
//  are sampled at the same time.
// For example, all there may be a struct series for a set of signals variables, all from a
//  process with an 'update()' function within which all all variables are sampled with the
//  same timestamp.
// DataBlocks will not directly reference this series, but only child series of this series.
// Struct series may reference other struct series, but the series structure must be a directed
//  acyclic graph (DAG): no circular reference structures.
type StructTypeDescriptor struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// A map of a name-reference to a series, identified by its series_identifer_hash.
	KeyToSeriesIdentifierHash map[string]uint64 `protobuf:"bytes,1,rep,name=key_to_series_identifier_hash,json=keyToSeriesIdentifierHash,proto3" json:"key_to_series_identifier_hash,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
}

func (x *StructTypeDescriptor) Reset() {
	*x = StructTypeDescriptor{}
	if protoimpl.UnsafeEnabled {
		mi := &file_bosdyn_api_bddf_proto_msgTypes[7]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *StructTypeDescriptor) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StructTypeDescriptor) ProtoMessage() {}

func (x *StructTypeDescriptor) ProtoReflect() protoreflect.Message {
	mi := &file_bosdyn_api_bddf_proto_msgTypes[7]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StructTypeDescriptor.ProtoReflect.Descriptor instead.
func (*StructTypeDescriptor) Descriptor() ([]byte, []int) {
	return file_bosdyn_api_bddf_proto_rawDescGZIP(), []int{7}
}

func (x *StructTypeDescriptor) GetKeyToSeriesIdentifierHash() map[string]uint64 {
	if x != nil {
		return x.KeyToSeriesIdentifierHash
	}
	return nil
}

// As a file is closed, a DescriptorBlock containing a FileIndex should be written.
// The FileIndex summarizes the data series stored in the file and the location of the
//  block-indexes for each type in the file.
// Each series is assigned a "series_index" within the file, and this index may be used to
//  index into the repeated fields in this message.
// E.g., for the series with series_index N, you can access its SeriesIdentifier by accessing
//  element N the of the series_identifiers repeated field.
type FileIndex struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// SeriesIdentifer for each series in this file.
	SeriesIdentifiers []*SeriesIdentifier `protobuf:"bytes,1,rep,name=series_identifiers,json=seriesIdentifiers,proto3" json:"series_identifiers,omitempty"`
	// The offset from the start of the file of the SeriesBlockIndex block for each series.
	SeriesBlockIndexOffsets []uint64 `protobuf:"varint,2,rep,packed,name=series_block_index_offsets,json=seriesBlockIndexOffsets,proto3" json:"series_block_index_offsets,omitempty"`
	// The hash of the series_identifier for each series.
	SeriesIdentifierHashes []uint64 `protobuf:"varint,3,rep,packed,name=series_identifier_hashes,json=seriesIdentifierHashes,proto3" json:"series_identifier_hashes,omitempty"`
}

func (x *FileIndex) Reset() {
	*x = FileIndex{}
	if protoimpl.UnsafeEnabled {
		mi := &file_bosdyn_api_bddf_proto_msgTypes[8]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *FileIndex) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FileIndex) ProtoMessage() {}

func (x *FileIndex) ProtoReflect() protoreflect.Message {
	mi := &file_bosdyn_api_bddf_proto_msgTypes[8]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FileIndex.ProtoReflect.Descriptor instead.
func (*FileIndex) Descriptor() ([]byte, []int) {
	return file_bosdyn_api_bddf_proto_rawDescGZIP(), []int{8}
}

func (x *FileIndex) GetSeriesIdentifiers() []*SeriesIdentifier {
	if x != nil {
		return x.SeriesIdentifiers
	}
	return nil
}

func (x *FileIndex) GetSeriesBlockIndexOffsets() []uint64 {
	if x != nil {
		return x.SeriesBlockIndexOffsets
	}
	return nil
}

func (x *FileIndex) GetSeriesIdentifierHashes() []uint64 {
	if x != nil {
		return x.SeriesIdentifierHashes
	}
	return nil
}

// This describes the location of the SeriesDescriptor DescriptorBlock for the series, and
//  the timestamp and location in the file of every data block in the series.
type SeriesBlockIndex struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The series_index for the series described by this index block.
	SeriesIndex uint32 `protobuf:"varint,1,opt,name=series_index,json=seriesIndex,proto3" json:"series_index,omitempty"`
	// Offset of type descriptor block from start of file.
	DescriptorFileOffset uint64 `protobuf:"varint,2,opt,name=descriptor_file_offset,json=descriptorFileOffset,proto3" json:"descriptor_file_offset,omitempty"`
	// The timestamp and location of each data block for this series.
	BlockEntries []*SeriesBlockIndex_BlockEntry `protobuf:"bytes,3,rep,name=block_entries,json=blockEntries,proto3" json:"block_entries,omitempty"`
	// The total size of the data stored in the data blocks of this series.
	TotalBytes uint64 `protobuf:"varint,4,opt,name=total_bytes,json=totalBytes,proto3" json:"total_bytes,omitempty"`
}

func (x *SeriesBlockIndex) Reset() {
	*x = SeriesBlockIndex{}
	if protoimpl.UnsafeEnabled {
		mi := &file_bosdyn_api_bddf_proto_msgTypes[9]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SeriesBlockIndex) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SeriesBlockIndex) ProtoMessage() {}

func (x *SeriesBlockIndex) ProtoReflect() protoreflect.Message {
	mi := &file_bosdyn_api_bddf_proto_msgTypes[9]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SeriesBlockIndex.ProtoReflect.Descriptor instead.
func (*SeriesBlockIndex) Descriptor() ([]byte, []int) {
	return file_bosdyn_api_bddf_proto_rawDescGZIP(), []int{9}
}

func (x *SeriesBlockIndex) GetSeriesIndex() uint32 {
	if x != nil {
		return x.SeriesIndex
	}
	return 0
}

func (x *SeriesBlockIndex) GetDescriptorFileOffset() uint64 {
	if x != nil {
		return x.DescriptorFileOffset
	}
	return 0
}

func (x *SeriesBlockIndex) GetBlockEntries() []*SeriesBlockIndex_BlockEntry {
	if x != nil {
		return x.BlockEntries
	}
	return nil
}

func (x *SeriesBlockIndex) GetTotalBytes() uint64 {
	if x != nil {
		return x.TotalBytes
	}
	return 0
}

// A key or description for selecting a message series.
// Because there may be multiple ways of describing a message series, we identify
//  them by a unique mapping of {key -> value}.
// A series_type corresponds to a set of keys which are expected in the mapping.
// A 'bosdyn:grpc:requests' series_type, containing GRPC robot-id request messages, might
//  thus be specified as:
//   {'service': 'robot_id', 'message': 'bosdyn.api.RobotIdRequest'}
// A 'bosdyn:logtick' series_type, containing a signals data variable from LogTick
//   annotations might be specified as:
//   {'varname': 'tablet.wifi.rssi', 'schema': 'tablet-comms', 'client': 'bd-tablet'}
type SeriesIdentifier struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// This is the kind of spec, which should correspond to a set of keys which are expected
	//  in the spec.
	SeriesType string `protobuf:"bytes,1,opt,name=series_type,json=seriesType,proto3" json:"series_type,omitempty"`
	// This is the "key" for naming the series within the file.
	// A key->value description which should be unique for this series within the file
	//  with this series_type.
	Spec map[string]string `protobuf:"bytes,2,rep,name=spec,proto3" json:"spec,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (x *SeriesIdentifier) Reset() {
	*x = SeriesIdentifier{}
	if protoimpl.UnsafeEnabled {
		mi := &file_bosdyn_api_bddf_proto_msgTypes[10]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SeriesIdentifier) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SeriesIdentifier) ProtoMessage() {}

func (x *SeriesIdentifier) ProtoReflect() protoreflect.Message {
	mi := &file_bosdyn_api_bddf_proto_msgTypes[10]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SeriesIdentifier.ProtoReflect.Descriptor instead.
func (*SeriesIdentifier) Descriptor() ([]byte, []int) {
	return file_bosdyn_api_bddf_proto_rawDescGZIP(), []int{10}
}

func (x *SeriesIdentifier) GetSeriesType() string {
	if x != nil {
		return x.SeriesType
	}
	return ""
}

func (x *SeriesIdentifier) GetSpec() map[string]string {
	if x != nil {
		return x.Spec
	}
	return nil
}

type SeriesBlockIndex_BlockEntry struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The timestamp of data in this block.
	Timestamp *timestamppb.Timestamp `protobuf:"bytes,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	// The offset of the data block from the start of the file.
	FileOffset uint64 `protobuf:"varint,2,opt,name=file_offset,json=fileOffset,proto3" json:"file_offset,omitempty"`
	// Values of the additional indexes for describing this block.
	AdditionalIndexes []int64 `protobuf:"varint,3,rep,packed,name=additional_indexes,json=additionalIndexes,proto3" json:"additional_indexes,omitempty"`
}

func (x *SeriesBlockIndex_BlockEntry) Reset() {
	*x = SeriesBlockIndex_BlockEntry{}
	if protoimpl.UnsafeEnabled {
		mi := &file_bosdyn_api_bddf_proto_msgTypes[14]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SeriesBlockIndex_BlockEntry) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SeriesBlockIndex_BlockEntry) ProtoMessage() {}

func (x *SeriesBlockIndex_BlockEntry) ProtoReflect() protoreflect.Message {
	mi := &file_bosdyn_api_bddf_proto_msgTypes[14]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SeriesBlockIndex_BlockEntry.ProtoReflect.Descriptor instead.
func (*SeriesBlockIndex_BlockEntry) Descriptor() ([]byte, []int) {
	return file_bosdyn_api_bddf_proto_rawDescGZIP(), []int{9, 0}
}

func (x *SeriesBlockIndex_BlockEntry) GetTimestamp() *timestamppb.Timestamp {
	if x != nil {
		return x.Timestamp
	}
	return nil
}

func (x *SeriesBlockIndex_BlockEntry) GetFileOffset() uint64 {
	if x != nil {
		return x.FileOffset
	}
	return 0
}

func (x *SeriesBlockIndex_BlockEntry) GetAdditionalIndexes() []int64 {
	if x != nil {
		return x.AdditionalIndexes
	}
	return nil
}

var File_bosdyn_api_bddf_proto protoreflect.FileDescriptor

var file_bosdyn_api_bddf_proto_rawDesc = []byte{
	0x0a, 0x15, 0x62, 0x6f, 0x73, 0x64, 0x79, 0x6e, 0x2f, 0x61, 0x70, 0x69, 0x2f, 0x62, 0x64, 0x64,
	0x66, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x0a, 0x62, 0x6f, 0x73, 0x64, 0x79, 0x6e, 0x2e,
	0x61, 0x70, 0x69, 0x1a, 0x1f, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2f, 0x70, 0x72, 0x6f, 0x74,
	0x6f, 0x62, 0x75, 0x66, 0x2f, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x2e, 0x70,
	0x72, 0x6f, 0x74, 0x6f, 0x22, 0xc3, 0x02, 0x0a, 0x0f, 0x44, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70,
	0x74, 0x6f, 0x72, 0x42, 0x6c, 0x6f, 0x63, 0x6b, 0x12, 0x4b, 0x0a, 0x0f, 0x66, 0x69, 0x6c, 0x65,
	0x5f, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x6f, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28,
	0x0b, 0x32, 0x20, 0x2e, 0x62, 0x6f, 0x73, 0x64, 0x79, 0x6e, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x46,
	0x69, 0x6c, 0x65, 0x46, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x44, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70,
	0x74, 0x6f, 0x72, 0x48, 0x00, 0x52, 0x0e, 0x66, 0x69, 0x6c, 0x65, 0x44, 0x65, 0x73, 0x63, 0x72,
	0x69, 0x70, 0x74, 0x6f, 0x72, 0x12, 0x4b, 0x0a, 0x11, 0x73, 0x65, 0x72, 0x69, 0x65, 0x73, 0x5f,
	0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x6f, 0x72, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b,
	0x32, 0x1c, 0x2e, 0x62, 0x6f, 0x73, 0x64, 0x79, 0x6e, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x53, 0x65,
	0x72, 0x69, 0x65, 0x73, 0x44, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x6f, 0x72, 0x48, 0x00,
	0x52, 0x10, 0x73, 0x65, 0x72, 0x69, 0x65, 0x73, 0x44, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74,
	0x6f, 0x72, 0x12, 0x4c, 0x0a, 0x12, 0x73, 0x65, 0x72, 0x69, 0x65, 0x73, 0x5f, 0x62, 0x6c, 0x6f,
	0x63, 0x6b, 0x5f, 0x69, 0x6e, 0x64, 0x65, 0x78, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1c,
	0x2e, 0x62, 0x6f, 0x73, 0x64, 0x79, 0x6e, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x53, 0x65, 0x72, 0x69,
	0x65, 0x73, 0x42, 0x6c, 0x6f, 0x63, 0x6b, 0x49, 0x6e, 0x64, 0x65, 0x78, 0x48, 0x00, 0x52, 0x10,
	0x73, 0x65, 0x72, 0x69, 0x65, 0x73, 0x42, 0x6c, 0x6f, 0x63, 0x6b, 0x49, 0x6e, 0x64, 0x65, 0x78,
	0x12, 0x36, 0x0a, 0x0a, 0x66, 0x69, 0x6c, 0x65, 0x5f, 0x69, 0x6e, 0x64, 0x65, 0x78, 0x18, 0x04,
	0x20, 0x01, 0x28, 0x0b, 0x32, 0x15, 0x2e, 0x62, 0x6f, 0x73, 0x64, 0x79, 0x6e, 0x2e, 0x61, 0x70,
	0x69, 0x2e, 0x46, 0x69, 0x6c, 0x65, 0x49, 0x6e, 0x64, 0x65, 0x78, 0x48, 0x00, 0x52, 0x09, 0x66,
	0x69, 0x6c, 0x65, 0x49, 0x6e, 0x64, 0x65, 0x78, 0x42, 0x10, 0x0a, 0x0e, 0x44, 0x65, 0x73, 0x63,
	0x72, 0x69, 0x70, 0x74, 0x6f, 0x72, 0x54, 0x79, 0x70, 0x65, 0x22, 0x9c, 0x01, 0x0a, 0x0e, 0x44,
	0x61, 0x74, 0x61, 0x44, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x6f, 0x72, 0x12, 0x21, 0x0a,
	0x0c, 0x73, 0x65, 0x72, 0x69, 0x65, 0x73, 0x5f, 0x69, 0x6e, 0x64, 0x65, 0x78, 0x18, 0x01, 0x20,
	0x01, 0x28, 0x0d, 0x52, 0x0b, 0x73, 0x65, 0x72, 0x69, 0x65, 0x73, 0x49, 0x6e, 0x64, 0x65, 0x78,
	0x12, 0x38, 0x0a, 0x09, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x18, 0x02, 0x20,
	0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f,
	0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x52,
	0x09, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x12, 0x2d, 0x0a, 0x12, 0x61, 0x64,
	0x64, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x61, 0x6c, 0x5f, 0x69, 0x6e, 0x64, 0x65, 0x78, 0x65, 0x73,
	0x18, 0x03, 0x20, 0x03, 0x28, 0x03, 0x52, 0x11, 0x61, 0x64, 0x64, 0x69, 0x74, 0x69, 0x6f, 0x6e,
	0x61, 0x6c, 0x49, 0x6e, 0x64, 0x65, 0x78, 0x65, 0x73, 0x22, 0xc1, 0x03, 0x0a, 0x14, 0x46, 0x69,
	0x6c, 0x65, 0x46, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x44, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74,
	0x6f, 0x72, 0x12, 0x37, 0x0a, 0x07, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x18, 0x01, 0x20,
	0x01, 0x28, 0x0b, 0x32, 0x1d, 0x2e, 0x62, 0x6f, 0x73, 0x64, 0x79, 0x6e, 0x2e, 0x61, 0x70, 0x69,
	0x2e, 0x46, 0x69, 0x6c, 0x65, 0x46, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x56, 0x65, 0x72, 0x73, 0x69,
	0x6f, 0x6e, 0x52, 0x07, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x12, 0x53, 0x0a, 0x0b, 0x61,
	0x6e, 0x6e, 0x6f, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0b,
	0x32, 0x31, 0x2e, 0x62, 0x6f, 0x73, 0x64, 0x79, 0x6e, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x46, 0x69,
	0x6c, 0x65, 0x46, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x44, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74,
	0x6f, 0x72, 0x2e, 0x41, 0x6e, 0x6e, 0x6f, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x45, 0x6e,
	0x74, 0x72, 0x79, 0x52, 0x0b, 0x61, 0x6e, 0x6e, 0x6f, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73,
	0x12, 0x52, 0x0a, 0x0d, 0x63, 0x68, 0x65, 0x63, 0x6b, 0x73, 0x75, 0x6d, 0x5f, 0x74, 0x79, 0x70,
	0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x2d, 0x2e, 0x62, 0x6f, 0x73, 0x64, 0x79, 0x6e,
	0x2e, 0x61, 0x70, 0x69, 0x2e, 0x46, 0x69, 0x6c, 0x65, 0x46, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x44,
	0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x6f, 0x72, 0x2e, 0x43, 0x68, 0x65, 0x63, 0x6b, 0x53,
	0x75, 0x6d, 0x54, 0x79, 0x70, 0x65, 0x52, 0x0c, 0x63, 0x68, 0x65, 0x63, 0x6b, 0x73, 0x75, 0x6d,
	0x54, 0x79, 0x70, 0x65, 0x12, 0x2c, 0x0a, 0x12, 0x63, 0x68, 0x65, 0x63, 0x6b, 0x73, 0x75, 0x6d,
	0x5f, 0x6e, 0x75, 0x6d, 0x5f, 0x62, 0x79, 0x74, 0x65, 0x73, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0d,
	0x52, 0x10, 0x63, 0x68, 0x65, 0x63, 0x6b, 0x73, 0x75, 0x6d, 0x4e, 0x75, 0x6d, 0x42, 0x79, 0x74,
	0x65, 0x73, 0x1a, 0x3e, 0x0a, 0x10, 0x41, 0x6e, 0x6e, 0x6f, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e,
	0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x01, 0x20,
	0x01, 0x28, 0x09, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x14, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75,
	0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x3a, 0x02,
	0x38, 0x01, 0x22, 0x59, 0x0a, 0x0c, 0x43, 0x68, 0x65, 0x63, 0x6b, 0x53, 0x75, 0x6d, 0x54, 0x79,
	0x70, 0x65, 0x12, 0x19, 0x0a, 0x15, 0x43, 0x48, 0x45, 0x43, 0x4b, 0x53, 0x55, 0x4d, 0x5f, 0x54,
	0x59, 0x50, 0x45, 0x5f, 0x55, 0x4e, 0x4b, 0x4e, 0x4f, 0x57, 0x4e, 0x10, 0x00, 0x12, 0x16, 0x0a,
	0x12, 0x43, 0x48, 0x45, 0x43, 0x4b, 0x53, 0x55, 0x4d, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x4e,
	0x4f, 0x4e, 0x45, 0x10, 0x01, 0x12, 0x16, 0x0a, 0x12, 0x43, 0x48, 0x45, 0x43, 0x4b, 0x53, 0x55,
	0x4d, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x53, 0x48, 0x41, 0x31, 0x10, 0x02, 0x22, 0x7e, 0x0a,
	0x11, 0x46, 0x69, 0x6c, 0x65, 0x46, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x56, 0x65, 0x72, 0x73, 0x69,
	0x6f, 0x6e, 0x12, 0x23, 0x0a, 0x0d, 0x6d, 0x61, 0x6a, 0x6f, 0x72, 0x5f, 0x76, 0x65, 0x72, 0x73,
	0x69, 0x6f, 0x6e, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x0c, 0x6d, 0x61, 0x6a, 0x6f, 0x72,
	0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x12, 0x23, 0x0a, 0x0d, 0x6d, 0x69, 0x6e, 0x6f, 0x72,
	0x5f, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x0c,
	0x6d, 0x69, 0x6e, 0x6f, 0x72, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x12, 0x1f, 0x0a, 0x0b,
	0x70, 0x61, 0x74, 0x63, 0x68, 0x5f, 0x6c, 0x65, 0x76, 0x65, 0x6c, 0x18, 0x03, 0x20, 0x01, 0x28,
	0x0d, 0x52, 0x0a, 0x70, 0x61, 0x74, 0x63, 0x68, 0x4c, 0x65, 0x76, 0x65, 0x6c, 0x22, 0xe7, 0x04,
	0x0a, 0x10, 0x53, 0x65, 0x72, 0x69, 0x65, 0x73, 0x44, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74,
	0x6f, 0x72, 0x12, 0x21, 0x0a, 0x0c, 0x73, 0x65, 0x72, 0x69, 0x65, 0x73, 0x5f, 0x69, 0x6e, 0x64,
	0x65, 0x78, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x0b, 0x73, 0x65, 0x72, 0x69, 0x65, 0x73,
	0x49, 0x6e, 0x64, 0x65, 0x78, 0x12, 0x49, 0x0a, 0x11, 0x73, 0x65, 0x72, 0x69, 0x65, 0x73, 0x5f,
	0x69, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x66, 0x69, 0x65, 0x72, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b,
	0x32, 0x1c, 0x2e, 0x62, 0x6f, 0x73, 0x64, 0x79, 0x6e, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x53, 0x65,
	0x72, 0x69, 0x65, 0x73, 0x49, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x66, 0x69, 0x65, 0x72, 0x52, 0x10,
	0x73, 0x65, 0x72, 0x69, 0x65, 0x73, 0x49, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x66, 0x69, 0x65, 0x72,
	0x12, 0x27, 0x0a, 0x0f, 0x69, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x66, 0x69, 0x65, 0x72, 0x5f, 0x68,
	0x61, 0x73, 0x68, 0x18, 0x03, 0x20, 0x01, 0x28, 0x04, 0x52, 0x0e, 0x69, 0x64, 0x65, 0x6e, 0x74,
	0x69, 0x66, 0x69, 0x65, 0x72, 0x48, 0x61, 0x73, 0x68, 0x12, 0x46, 0x0a, 0x0c, 0x6d, 0x65, 0x73,
	0x73, 0x61, 0x67, 0x65, 0x5f, 0x74, 0x79, 0x70, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32,
	0x21, 0x2e, 0x62, 0x6f, 0x73, 0x64, 0x79, 0x6e, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x4d, 0x65, 0x73,
	0x73, 0x61, 0x67, 0x65, 0x54, 0x79, 0x70, 0x65, 0x44, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74,
	0x6f, 0x72, 0x48, 0x00, 0x52, 0x0b, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x54, 0x79, 0x70,
	0x65, 0x12, 0x3a, 0x0a, 0x08, 0x70, 0x6f, 0x64, 0x5f, 0x74, 0x79, 0x70, 0x65, 0x18, 0x05, 0x20,
	0x01, 0x28, 0x0b, 0x32, 0x1d, 0x2e, 0x62, 0x6f, 0x73, 0x64, 0x79, 0x6e, 0x2e, 0x61, 0x70, 0x69,
	0x2e, 0x50, 0x6f, 0x64, 0x54, 0x79, 0x70, 0x65, 0x44, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74,
	0x6f, 0x72, 0x48, 0x00, 0x52, 0x07, 0x70, 0x6f, 0x64, 0x54, 0x79, 0x70, 0x65, 0x12, 0x43, 0x0a,
	0x0b, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x5f, 0x74, 0x79, 0x70, 0x65, 0x18, 0x06, 0x20, 0x01,
	0x28, 0x0b, 0x32, 0x20, 0x2e, 0x62, 0x6f, 0x73, 0x64, 0x79, 0x6e, 0x2e, 0x61, 0x70, 0x69, 0x2e,
	0x53, 0x74, 0x72, 0x75, 0x63, 0x74, 0x54, 0x79, 0x70, 0x65, 0x44, 0x65, 0x73, 0x63, 0x72, 0x69,
	0x70, 0x74, 0x6f, 0x72, 0x48, 0x00, 0x52, 0x0a, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x54, 0x79,
	0x70, 0x65, 0x12, 0x4f, 0x0a, 0x0b, 0x61, 0x6e, 0x6e, 0x6f, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e,
	0x73, 0x18, 0x07, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x2d, 0x2e, 0x62, 0x6f, 0x73, 0x64, 0x79, 0x6e,
	0x2e, 0x61, 0x70, 0x69, 0x2e, 0x53, 0x65, 0x72, 0x69, 0x65, 0x73, 0x44, 0x65, 0x73, 0x63, 0x72,
	0x69, 0x70, 0x74, 0x6f, 0x72, 0x2e, 0x41, 0x6e, 0x6e, 0x6f, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e,
	0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x52, 0x0b, 0x61, 0x6e, 0x6e, 0x6f, 0x74, 0x61, 0x74, 0x69,
	0x6f, 0x6e, 0x73, 0x12, 0x34, 0x0a, 0x16, 0x61, 0x64, 0x64, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x61,
	0x6c, 0x5f, 0x69, 0x6e, 0x64, 0x65, 0x78, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x73, 0x18, 0x08, 0x20,
	0x03, 0x28, 0x09, 0x52, 0x14, 0x61, 0x64, 0x64, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x61, 0x6c, 0x49,
	0x6e, 0x64, 0x65, 0x78, 0x4e, 0x61, 0x6d, 0x65, 0x73, 0x12, 0x20, 0x0a, 0x0b, 0x64, 0x65, 0x73,
	0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x09, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b,
	0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x1a, 0x3e, 0x0a, 0x10, 0x41,
	0x6e, 0x6e, 0x6f, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x12,
	0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6b, 0x65,
	0x79, 0x12, 0x14, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09,
	0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x3a, 0x02, 0x38, 0x01, 0x42, 0x0a, 0x0a, 0x08, 0x44,
	0x61, 0x74, 0x61, 0x54, 0x79, 0x70, 0x65, 0x22, 0x78, 0x0a, 0x15, 0x4d, 0x65, 0x73, 0x73, 0x61,
	0x67, 0x65, 0x54, 0x79, 0x70, 0x65, 0x44, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x6f, 0x72,
	0x12, 0x21, 0x0a, 0x0c, 0x63, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x5f, 0x74, 0x79, 0x70, 0x65,
	0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x63, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x54,
	0x79, 0x70, 0x65, 0x12, 0x1b, 0x0a, 0x09, 0x74, 0x79, 0x70, 0x65, 0x5f, 0x6e, 0x61, 0x6d, 0x65,
	0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x74, 0x79, 0x70, 0x65, 0x4e, 0x61, 0x6d, 0x65,
	0x12, 0x1f, 0x0a, 0x0b, 0x69, 0x73, 0x5f, 0x6d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x18,
	0x03, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0a, 0x69, 0x73, 0x4d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74,
	0x61, 0x22, 0x65, 0x0a, 0x11, 0x50, 0x6f, 0x64, 0x54, 0x79, 0x70, 0x65, 0x44, 0x65, 0x73, 0x63,
	0x72, 0x69, 0x70, 0x74, 0x6f, 0x72, 0x12, 0x32, 0x0a, 0x08, 0x70, 0x6f, 0x64, 0x5f, 0x74, 0x79,
	0x70, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x17, 0x2e, 0x62, 0x6f, 0x73, 0x64, 0x79,
	0x6e, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x50, 0x6f, 0x64, 0x54, 0x79, 0x70, 0x65, 0x45, 0x6e, 0x75,
	0x6d, 0x52, 0x07, 0x70, 0x6f, 0x64, 0x54, 0x79, 0x70, 0x65, 0x12, 0x1c, 0x0a, 0x09, 0x64, 0x69,
	0x6d, 0x65, 0x6e, 0x73, 0x69, 0x6f, 0x6e, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0d, 0x52, 0x09, 0x64,
	0x69, 0x6d, 0x65, 0x6e, 0x73, 0x69, 0x6f, 0x6e, 0x22, 0xe8, 0x01, 0x0a, 0x14, 0x53, 0x74, 0x72,
	0x75, 0x63, 0x74, 0x54, 0x79, 0x70, 0x65, 0x44, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x6f,
	0x72, 0x12, 0x81, 0x01, 0x0a, 0x1d, 0x6b, 0x65, 0x79, 0x5f, 0x74, 0x6f, 0x5f, 0x73, 0x65, 0x72,
	0x69, 0x65, 0x73, 0x5f, 0x69, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x66, 0x69, 0x65, 0x72, 0x5f, 0x68,
	0x61, 0x73, 0x68, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x3f, 0x2e, 0x62, 0x6f, 0x73, 0x64,
	0x79, 0x6e, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x53, 0x74, 0x72, 0x75, 0x63, 0x74, 0x54, 0x79, 0x70,
	0x65, 0x44, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x6f, 0x72, 0x2e, 0x4b, 0x65, 0x79, 0x54,
	0x6f, 0x53, 0x65, 0x72, 0x69, 0x65, 0x73, 0x49, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x66, 0x69, 0x65,
	0x72, 0x48, 0x61, 0x73, 0x68, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x52, 0x19, 0x6b, 0x65, 0x79, 0x54,
	0x6f, 0x53, 0x65, 0x72, 0x69, 0x65, 0x73, 0x49, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x66, 0x69, 0x65,
	0x72, 0x48, 0x61, 0x73, 0x68, 0x1a, 0x4c, 0x0a, 0x1e, 0x4b, 0x65, 0x79, 0x54, 0x6f, 0x53, 0x65,
	0x72, 0x69, 0x65, 0x73, 0x49, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x66, 0x69, 0x65, 0x72, 0x48, 0x61,
	0x73, 0x68, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x01,
	0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x14, 0x0a, 0x05, 0x76, 0x61, 0x6c,
	0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x04, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x3a,
	0x02, 0x38, 0x01, 0x22, 0xcf, 0x01, 0x0a, 0x09, 0x46, 0x69, 0x6c, 0x65, 0x49, 0x6e, 0x64, 0x65,
	0x78, 0x12, 0x4b, 0x0a, 0x12, 0x73, 0x65, 0x72, 0x69, 0x65, 0x73, 0x5f, 0x69, 0x64, 0x65, 0x6e,
	0x74, 0x69, 0x66, 0x69, 0x65, 0x72, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x1c, 0x2e,
	0x62, 0x6f, 0x73, 0x64, 0x79, 0x6e, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x53, 0x65, 0x72, 0x69, 0x65,
	0x73, 0x49, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x66, 0x69, 0x65, 0x72, 0x52, 0x11, 0x73, 0x65, 0x72,
	0x69, 0x65, 0x73, 0x49, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x66, 0x69, 0x65, 0x72, 0x73, 0x12, 0x3b,
	0x0a, 0x1a, 0x73, 0x65, 0x72, 0x69, 0x65, 0x73, 0x5f, 0x62, 0x6c, 0x6f, 0x63, 0x6b, 0x5f, 0x69,
	0x6e, 0x64, 0x65, 0x78, 0x5f, 0x6f, 0x66, 0x66, 0x73, 0x65, 0x74, 0x73, 0x18, 0x02, 0x20, 0x03,
	0x28, 0x04, 0x52, 0x17, 0x73, 0x65, 0x72, 0x69, 0x65, 0x73, 0x42, 0x6c, 0x6f, 0x63, 0x6b, 0x49,
	0x6e, 0x64, 0x65, 0x78, 0x4f, 0x66, 0x66, 0x73, 0x65, 0x74, 0x73, 0x12, 0x38, 0x0a, 0x18, 0x73,
	0x65, 0x72, 0x69, 0x65, 0x73, 0x5f, 0x69, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x66, 0x69, 0x65, 0x72,
	0x5f, 0x68, 0x61, 0x73, 0x68, 0x65, 0x73, 0x18, 0x03, 0x20, 0x03, 0x28, 0x04, 0x52, 0x16, 0x73,
	0x65, 0x72, 0x69, 0x65, 0x73, 0x49, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x66, 0x69, 0x65, 0x72, 0x48,
	0x61, 0x73, 0x68, 0x65, 0x73, 0x22, 0xf3, 0x02, 0x0a, 0x10, 0x53, 0x65, 0x72, 0x69, 0x65, 0x73,
	0x42, 0x6c, 0x6f, 0x63, 0x6b, 0x49, 0x6e, 0x64, 0x65, 0x78, 0x12, 0x21, 0x0a, 0x0c, 0x73, 0x65,
	0x72, 0x69, 0x65, 0x73, 0x5f, 0x69, 0x6e, 0x64, 0x65, 0x78, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d,
	0x52, 0x0b, 0x73, 0x65, 0x72, 0x69, 0x65, 0x73, 0x49, 0x6e, 0x64, 0x65, 0x78, 0x12, 0x34, 0x0a,
	0x16, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x6f, 0x72, 0x5f, 0x66, 0x69, 0x6c, 0x65,
	0x5f, 0x6f, 0x66, 0x66, 0x73, 0x65, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x04, 0x52, 0x14, 0x64,
	0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x6f, 0x72, 0x46, 0x69, 0x6c, 0x65, 0x4f, 0x66, 0x66,
	0x73, 0x65, 0x74, 0x12, 0x4c, 0x0a, 0x0d, 0x62, 0x6c, 0x6f, 0x63, 0x6b, 0x5f, 0x65, 0x6e, 0x74,
	0x72, 0x69, 0x65, 0x73, 0x18, 0x03, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x27, 0x2e, 0x62, 0x6f, 0x73,
	0x64, 0x79, 0x6e, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x53, 0x65, 0x72, 0x69, 0x65, 0x73, 0x42, 0x6c,
	0x6f, 0x63, 0x6b, 0x49, 0x6e, 0x64, 0x65, 0x78, 0x2e, 0x42, 0x6c, 0x6f, 0x63, 0x6b, 0x45, 0x6e,
	0x74, 0x72, 0x79, 0x52, 0x0c, 0x62, 0x6c, 0x6f, 0x63, 0x6b, 0x45, 0x6e, 0x74, 0x72, 0x69, 0x65,
	0x73, 0x12, 0x1f, 0x0a, 0x0b, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x62, 0x79, 0x74, 0x65, 0x73,
	0x18, 0x04, 0x20, 0x01, 0x28, 0x04, 0x52, 0x0a, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x42, 0x79, 0x74,
	0x65, 0x73, 0x1a, 0x96, 0x01, 0x0a, 0x0a, 0x42, 0x6c, 0x6f, 0x63, 0x6b, 0x45, 0x6e, 0x74, 0x72,
	0x79, 0x12, 0x38, 0x0a, 0x09, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x18, 0x01,
	0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72,
	0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70,
	0x52, 0x09, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x12, 0x1f, 0x0a, 0x0b, 0x66,
	0x69, 0x6c, 0x65, 0x5f, 0x6f, 0x66, 0x66, 0x73, 0x65, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x04,
	0x52, 0x0a, 0x66, 0x69, 0x6c, 0x65, 0x4f, 0x66, 0x66, 0x73, 0x65, 0x74, 0x12, 0x2d, 0x0a, 0x12,
	0x61, 0x64, 0x64, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x61, 0x6c, 0x5f, 0x69, 0x6e, 0x64, 0x65, 0x78,
	0x65, 0x73, 0x18, 0x03, 0x20, 0x03, 0x28, 0x03, 0x52, 0x11, 0x61, 0x64, 0x64, 0x69, 0x74, 0x69,
	0x6f, 0x6e, 0x61, 0x6c, 0x49, 0x6e, 0x64, 0x65, 0x78, 0x65, 0x73, 0x22, 0xa8, 0x01, 0x0a, 0x10,
	0x53, 0x65, 0x72, 0x69, 0x65, 0x73, 0x49, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x66, 0x69, 0x65, 0x72,
	0x12, 0x1f, 0x0a, 0x0b, 0x73, 0x65, 0x72, 0x69, 0x65, 0x73, 0x5f, 0x74, 0x79, 0x70, 0x65, 0x18,
	0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0a, 0x73, 0x65, 0x72, 0x69, 0x65, 0x73, 0x54, 0x79, 0x70,
	0x65, 0x12, 0x3a, 0x0a, 0x04, 0x73, 0x70, 0x65, 0x63, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0b, 0x32,
	0x26, 0x2e, 0x62, 0x6f, 0x73, 0x64, 0x79, 0x6e, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x53, 0x65, 0x72,
	0x69, 0x65, 0x73, 0x49, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x66, 0x69, 0x65, 0x72, 0x2e, 0x53, 0x70,
	0x65, 0x63, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x52, 0x04, 0x73, 0x70, 0x65, 0x63, 0x1a, 0x37, 0x0a,
	0x09, 0x53, 0x70, 0x65, 0x63, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65,
	0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x14, 0x0a, 0x05,
	0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x76, 0x61, 0x6c,
	0x75, 0x65, 0x3a, 0x02, 0x38, 0x01, 0x2a, 0xc9, 0x01, 0x0a, 0x0b, 0x50, 0x6f, 0x64, 0x54, 0x79,
	0x70, 0x65, 0x45, 0x6e, 0x75, 0x6d, 0x12, 0x14, 0x0a, 0x10, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x55,
	0x4e, 0x53, 0x50, 0x45, 0x43, 0x49, 0x46, 0x49, 0x45, 0x44, 0x10, 0x00, 0x12, 0x0d, 0x0a, 0x09,
	0x54, 0x59, 0x50, 0x45, 0x5f, 0x49, 0x4e, 0x54, 0x38, 0x10, 0x01, 0x12, 0x0e, 0x0a, 0x0a, 0x54,
	0x59, 0x50, 0x45, 0x5f, 0x49, 0x4e, 0x54, 0x31, 0x36, 0x10, 0x02, 0x12, 0x0e, 0x0a, 0x0a, 0x54,
	0x59, 0x50, 0x45, 0x5f, 0x49, 0x4e, 0x54, 0x33, 0x32, 0x10, 0x03, 0x12, 0x0e, 0x0a, 0x0a, 0x54,
	0x59, 0x50, 0x45, 0x5f, 0x49, 0x4e, 0x54, 0x36, 0x34, 0x10, 0x04, 0x12, 0x0e, 0x0a, 0x0a, 0x54,
	0x59, 0x50, 0x45, 0x5f, 0x55, 0x49, 0x4e, 0x54, 0x38, 0x10, 0x05, 0x12, 0x0f, 0x0a, 0x0b, 0x54,
	0x59, 0x50, 0x45, 0x5f, 0x55, 0x49, 0x4e, 0x54, 0x31, 0x36, 0x10, 0x06, 0x12, 0x0f, 0x0a, 0x0b,
	0x54, 0x59, 0x50, 0x45, 0x5f, 0x55, 0x49, 0x4e, 0x54, 0x33, 0x32, 0x10, 0x07, 0x12, 0x0f, 0x0a,
	0x0b, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x55, 0x49, 0x4e, 0x54, 0x36, 0x34, 0x10, 0x08, 0x12, 0x10,
	0x0a, 0x0c, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x46, 0x4c, 0x4f, 0x41, 0x54, 0x33, 0x32, 0x10, 0x09,
	0x12, 0x10, 0x0a, 0x0c, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x46, 0x4c, 0x4f, 0x41, 0x54, 0x36, 0x34,
	0x10, 0x0a, 0x42, 0x33, 0x5a, 0x31, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d,
	0x2f, 0x6b, 0x68, 0x73, 0x73, 0x6e, 0x76, 0x2f, 0x73, 0x70, 0x6f, 0x74, 0x2d, 0x73, 0x64, 0x6b,
	0x2f, 0x70, 0x72, 0x65, 0x62, 0x75, 0x69, 0x6c, 0x74, 0x2f, 0x67, 0x6f, 0x2f, 0x62, 0x6f, 0x73,
	0x64, 0x79, 0x6e, 0x2f, 0x61, 0x70, 0x69, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
	file_bosdyn_api_bddf_proto_rawDescOnce sync.Once
	file_bosdyn_api_bddf_proto_rawDescData = file_bosdyn_api_bddf_proto_rawDesc
)

func file_bosdyn_api_bddf_proto_rawDescGZIP() []byte {
	file_bosdyn_api_bddf_proto_rawDescOnce.Do(func() {
		file_bosdyn_api_bddf_proto_rawDescData = protoimpl.X.CompressGZIP(file_bosdyn_api_bddf_proto_rawDescData)
	})
	return file_bosdyn_api_bddf_proto_rawDescData
}

var file_bosdyn_api_bddf_proto_enumTypes = make([]protoimpl.EnumInfo, 2)
var file_bosdyn_api_bddf_proto_msgTypes = make([]protoimpl.MessageInfo, 16)
var file_bosdyn_api_bddf_proto_goTypes = []interface{}{
	(PodTypeEnum)(0),                       // 0: bosdyn.api.PodTypeEnum
	(FileFormatDescriptor_CheckSumType)(0), // 1: bosdyn.api.FileFormatDescriptor.CheckSumType
	(*DescriptorBlock)(nil),                // 2: bosdyn.api.DescriptorBlock
	(*DataDescriptor)(nil),                 // 3: bosdyn.api.DataDescriptor
	(*FileFormatDescriptor)(nil),           // 4: bosdyn.api.FileFormatDescriptor
	(*FileFormatVersion)(nil),              // 5: bosdyn.api.FileFormatVersion
	(*SeriesDescriptor)(nil),               // 6: bosdyn.api.SeriesDescriptor
	(*MessageTypeDescriptor)(nil),          // 7: bosdyn.api.MessageTypeDescriptor
	(*PodTypeDescriptor)(nil),              // 8: bosdyn.api.PodTypeDescriptor
	(*StructTypeDescriptor)(nil),           // 9: bosdyn.api.StructTypeDescriptor
	(*FileIndex)(nil),                      // 10: bosdyn.api.FileIndex
	(*SeriesBlockIndex)(nil),               // 11: bosdyn.api.SeriesBlockIndex
	(*SeriesIdentifier)(nil),               // 12: bosdyn.api.SeriesIdentifier
	nil,                                    // 13: bosdyn.api.FileFormatDescriptor.AnnotationsEntry
	nil,                                    // 14: bosdyn.api.SeriesDescriptor.AnnotationsEntry
	nil,                                    // 15: bosdyn.api.StructTypeDescriptor.KeyToSeriesIdentifierHashEntry
	(*SeriesBlockIndex_BlockEntry)(nil),    // 16: bosdyn.api.SeriesBlockIndex.BlockEntry
	nil,                                    // 17: bosdyn.api.SeriesIdentifier.SpecEntry
	(*timestamppb.Timestamp)(nil),          // 18: google.protobuf.Timestamp
}
var file_bosdyn_api_bddf_proto_depIdxs = []int32{
	4,  // 0: bosdyn.api.DescriptorBlock.file_descriptor:type_name -> bosdyn.api.FileFormatDescriptor
	6,  // 1: bosdyn.api.DescriptorBlock.series_descriptor:type_name -> bosdyn.api.SeriesDescriptor
	11, // 2: bosdyn.api.DescriptorBlock.series_block_index:type_name -> bosdyn.api.SeriesBlockIndex
	10, // 3: bosdyn.api.DescriptorBlock.file_index:type_name -> bosdyn.api.FileIndex
	18, // 4: bosdyn.api.DataDescriptor.timestamp:type_name -> google.protobuf.Timestamp
	5,  // 5: bosdyn.api.FileFormatDescriptor.version:type_name -> bosdyn.api.FileFormatVersion
	13, // 6: bosdyn.api.FileFormatDescriptor.annotations:type_name -> bosdyn.api.FileFormatDescriptor.AnnotationsEntry
	1,  // 7: bosdyn.api.FileFormatDescriptor.checksum_type:type_name -> bosdyn.api.FileFormatDescriptor.CheckSumType
	12, // 8: bosdyn.api.SeriesDescriptor.series_identifier:type_name -> bosdyn.api.SeriesIdentifier
	7,  // 9: bosdyn.api.SeriesDescriptor.message_type:type_name -> bosdyn.api.MessageTypeDescriptor
	8,  // 10: bosdyn.api.SeriesDescriptor.pod_type:type_name -> bosdyn.api.PodTypeDescriptor
	9,  // 11: bosdyn.api.SeriesDescriptor.struct_type:type_name -> bosdyn.api.StructTypeDescriptor
	14, // 12: bosdyn.api.SeriesDescriptor.annotations:type_name -> bosdyn.api.SeriesDescriptor.AnnotationsEntry
	0,  // 13: bosdyn.api.PodTypeDescriptor.pod_type:type_name -> bosdyn.api.PodTypeEnum
	15, // 14: bosdyn.api.StructTypeDescriptor.key_to_series_identifier_hash:type_name -> bosdyn.api.StructTypeDescriptor.KeyToSeriesIdentifierHashEntry
	12, // 15: bosdyn.api.FileIndex.series_identifiers:type_name -> bosdyn.api.SeriesIdentifier
	16, // 16: bosdyn.api.SeriesBlockIndex.block_entries:type_name -> bosdyn.api.SeriesBlockIndex.BlockEntry
	17, // 17: bosdyn.api.SeriesIdentifier.spec:type_name -> bosdyn.api.SeriesIdentifier.SpecEntry
	18, // 18: bosdyn.api.SeriesBlockIndex.BlockEntry.timestamp:type_name -> google.protobuf.Timestamp
	19, // [19:19] is the sub-list for method output_type
	19, // [19:19] is the sub-list for method input_type
	19, // [19:19] is the sub-list for extension type_name
	19, // [19:19] is the sub-list for extension extendee
	0,  // [0:19] is the sub-list for field type_name
}

func init() { file_bosdyn_api_bddf_proto_init() }
func file_bosdyn_api_bddf_proto_init() {
	if File_bosdyn_api_bddf_proto != nil {
		return
	}
	if !protoimpl.UnsafeEnabled {
		file_bosdyn_api_bddf_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*DescriptorBlock); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_bosdyn_api_bddf_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*DataDescriptor); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_bosdyn_api_bddf_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*FileFormatDescriptor); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_bosdyn_api_bddf_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*FileFormatVersion); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_bosdyn_api_bddf_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SeriesDescriptor); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_bosdyn_api_bddf_proto_msgTypes[5].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*MessageTypeDescriptor); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_bosdyn_api_bddf_proto_msgTypes[6].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*PodTypeDescriptor); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_bosdyn_api_bddf_proto_msgTypes[7].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*StructTypeDescriptor); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_bosdyn_api_bddf_proto_msgTypes[8].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*FileIndex); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_bosdyn_api_bddf_proto_msgTypes[9].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SeriesBlockIndex); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_bosdyn_api_bddf_proto_msgTypes[10].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SeriesIdentifier); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_bosdyn_api_bddf_proto_msgTypes[14].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SeriesBlockIndex_BlockEntry); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
	}
	file_bosdyn_api_bddf_proto_msgTypes[0].OneofWrappers = []interface{}{
		(*DescriptorBlock_FileDescriptor)(nil),
		(*DescriptorBlock_SeriesDescriptor)(nil),
		(*DescriptorBlock_SeriesBlockIndex)(nil),
		(*DescriptorBlock_FileIndex)(nil),
	}
	file_bosdyn_api_bddf_proto_msgTypes[4].OneofWrappers = []interface{}{
		(*SeriesDescriptor_MessageType)(nil),
		(*SeriesDescriptor_PodType)(nil),
		(*SeriesDescriptor_StructType)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: file_bosdyn_api_bddf_proto_rawDesc,
			NumEnums:      2,
			NumMessages:   16,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_bosdyn_api_bddf_proto_goTypes,
		DependencyIndexes: file_bosdyn_api_bddf_proto_depIdxs,
		EnumInfos:         file_bosdyn_api_bddf_proto_enumTypes,
		MessageInfos:      file_bosdyn_api_bddf_proto_msgTypes,
	}.Build()
	File_bosdyn_api_bddf_proto = out.File
	file_bosdyn_api_bddf_proto_rawDesc = nil
	file_bosdyn_api_bddf_proto_goTypes = nil
	file_bosdyn_api_bddf_proto_depIdxs = nil
}
