// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.17.3
// source: bosdyn/api/spot_cam/service.proto

package spot_cam

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// CompositorServiceClient is the client API for CompositorService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CompositorServiceClient interface {
	//SetScreen changes the current view that is streamed over the network
	SetScreen(ctx context.Context, in *SetScreenRequest, opts ...grpc.CallOption) (*SetScreenResponse, error)
	//GetScreen returns the currently-selected screen
	GetScreen(ctx context.Context, in *GetScreenRequest, opts ...grpc.CallOption) (*GetScreenResponse, error)
	//ListScreens returns a list of available screens
	ListScreens(ctx context.Context, in *ListScreensRequest, opts ...grpc.CallOption) (*ListScreensResponse, error)
	//GetVisibleCameras returns a list of currently visible windows, with any available metadata
	GetVisibleCameras(ctx context.Context, in *GetVisibleCamerasRequest, opts ...grpc.CallOption) (*GetVisibleCamerasResponse, error)
	//set the mapping between radiometric IR samples to color, for video
	SetIrColormap(ctx context.Context, in *SetIrColormapRequest, opts ...grpc.CallOption) (*SetIrColormapResponse, error)
	//get the mapping between radiometric IR samples to color, for video
	GetIrColormap(ctx context.Context, in *GetIrColormapRequest, opts ...grpc.CallOption) (*GetIrColormapResponse, error)
	//apply settings for the 'ir meter overlay'
	SetIrMeterOverlay(ctx context.Context, in *SetIrMeterOverlayRequest, opts ...grpc.CallOption) (*SetIrMeterOverlayResponse, error)
}

type compositorServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewCompositorServiceClient(cc grpc.ClientConnInterface) CompositorServiceClient {
	return &compositorServiceClient{cc}
}

func (c *compositorServiceClient) SetScreen(ctx context.Context, in *SetScreenRequest, opts ...grpc.CallOption) (*SetScreenResponse, error) {
	out := new(SetScreenResponse)
	err := c.cc.Invoke(ctx, "/bosdyn.api.spot_cam.CompositorService/SetScreen", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *compositorServiceClient) GetScreen(ctx context.Context, in *GetScreenRequest, opts ...grpc.CallOption) (*GetScreenResponse, error) {
	out := new(GetScreenResponse)
	err := c.cc.Invoke(ctx, "/bosdyn.api.spot_cam.CompositorService/GetScreen", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *compositorServiceClient) ListScreens(ctx context.Context, in *ListScreensRequest, opts ...grpc.CallOption) (*ListScreensResponse, error) {
	out := new(ListScreensResponse)
	err := c.cc.Invoke(ctx, "/bosdyn.api.spot_cam.CompositorService/ListScreens", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *compositorServiceClient) GetVisibleCameras(ctx context.Context, in *GetVisibleCamerasRequest, opts ...grpc.CallOption) (*GetVisibleCamerasResponse, error) {
	out := new(GetVisibleCamerasResponse)
	err := c.cc.Invoke(ctx, "/bosdyn.api.spot_cam.CompositorService/GetVisibleCameras", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *compositorServiceClient) SetIrColormap(ctx context.Context, in *SetIrColormapRequest, opts ...grpc.CallOption) (*SetIrColormapResponse, error) {
	out := new(SetIrColormapResponse)
	err := c.cc.Invoke(ctx, "/bosdyn.api.spot_cam.CompositorService/SetIrColormap", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *compositorServiceClient) GetIrColormap(ctx context.Context, in *GetIrColormapRequest, opts ...grpc.CallOption) (*GetIrColormapResponse, error) {
	out := new(GetIrColormapResponse)
	err := c.cc.Invoke(ctx, "/bosdyn.api.spot_cam.CompositorService/GetIrColormap", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *compositorServiceClient) SetIrMeterOverlay(ctx context.Context, in *SetIrMeterOverlayRequest, opts ...grpc.CallOption) (*SetIrMeterOverlayResponse, error) {
	out := new(SetIrMeterOverlayResponse)
	err := c.cc.Invoke(ctx, "/bosdyn.api.spot_cam.CompositorService/SetIrMeterOverlay", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CompositorServiceServer is the server API for CompositorService service.
// All implementations must embed UnimplementedCompositorServiceServer
// for forward compatibility
type CompositorServiceServer interface {
	//SetScreen changes the current view that is streamed over the network
	SetScreen(context.Context, *SetScreenRequest) (*SetScreenResponse, error)
	//GetScreen returns the currently-selected screen
	GetScreen(context.Context, *GetScreenRequest) (*GetScreenResponse, error)
	//ListScreens returns a list of available screens
	ListScreens(context.Context, *ListScreensRequest) (*ListScreensResponse, error)
	//GetVisibleCameras returns a list of currently visible windows, with any available metadata
	GetVisibleCameras(context.Context, *GetVisibleCamerasRequest) (*GetVisibleCamerasResponse, error)
	//set the mapping between radiometric IR samples to color, for video
	SetIrColormap(context.Context, *SetIrColormapRequest) (*SetIrColormapResponse, error)
	//get the mapping between radiometric IR samples to color, for video
	GetIrColormap(context.Context, *GetIrColormapRequest) (*GetIrColormapResponse, error)
	//apply settings for the 'ir meter overlay'
	SetIrMeterOverlay(context.Context, *SetIrMeterOverlayRequest) (*SetIrMeterOverlayResponse, error)
	mustEmbedUnimplementedCompositorServiceServer()
}

// UnimplementedCompositorServiceServer must be embedded to have forward compatible implementations.
type UnimplementedCompositorServiceServer struct {
}

func (UnimplementedCompositorServiceServer) SetScreen(context.Context, *SetScreenRequest) (*SetScreenResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetScreen not implemented")
}
func (UnimplementedCompositorServiceServer) GetScreen(context.Context, *GetScreenRequest) (*GetScreenResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetScreen not implemented")
}
func (UnimplementedCompositorServiceServer) ListScreens(context.Context, *ListScreensRequest) (*ListScreensResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListScreens not implemented")
}
func (UnimplementedCompositorServiceServer) GetVisibleCameras(context.Context, *GetVisibleCamerasRequest) (*GetVisibleCamerasResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetVisibleCameras not implemented")
}
func (UnimplementedCompositorServiceServer) SetIrColormap(context.Context, *SetIrColormapRequest) (*SetIrColormapResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetIrColormap not implemented")
}
func (UnimplementedCompositorServiceServer) GetIrColormap(context.Context, *GetIrColormapRequest) (*GetIrColormapResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetIrColormap not implemented")
}
func (UnimplementedCompositorServiceServer) SetIrMeterOverlay(context.Context, *SetIrMeterOverlayRequest) (*SetIrMeterOverlayResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetIrMeterOverlay not implemented")
}
func (UnimplementedCompositorServiceServer) mustEmbedUnimplementedCompositorServiceServer() {}

// UnsafeCompositorServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CompositorServiceServer will
// result in compilation errors.
type UnsafeCompositorServiceServer interface {
	mustEmbedUnimplementedCompositorServiceServer()
}

func RegisterCompositorServiceServer(s grpc.ServiceRegistrar, srv CompositorServiceServer) {
	s.RegisterService(&CompositorService_ServiceDesc, srv)
}

func _CompositorService_SetScreen_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetScreenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CompositorServiceServer).SetScreen(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bosdyn.api.spot_cam.CompositorService/SetScreen",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CompositorServiceServer).SetScreen(ctx, req.(*SetScreenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CompositorService_GetScreen_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetScreenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CompositorServiceServer).GetScreen(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bosdyn.api.spot_cam.CompositorService/GetScreen",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CompositorServiceServer).GetScreen(ctx, req.(*GetScreenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CompositorService_ListScreens_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListScreensRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CompositorServiceServer).ListScreens(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bosdyn.api.spot_cam.CompositorService/ListScreens",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CompositorServiceServer).ListScreens(ctx, req.(*ListScreensRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CompositorService_GetVisibleCameras_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetVisibleCamerasRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CompositorServiceServer).GetVisibleCameras(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bosdyn.api.spot_cam.CompositorService/GetVisibleCameras",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CompositorServiceServer).GetVisibleCameras(ctx, req.(*GetVisibleCamerasRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CompositorService_SetIrColormap_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetIrColormapRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CompositorServiceServer).SetIrColormap(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bosdyn.api.spot_cam.CompositorService/SetIrColormap",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CompositorServiceServer).SetIrColormap(ctx, req.(*SetIrColormapRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CompositorService_GetIrColormap_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetIrColormapRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CompositorServiceServer).GetIrColormap(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bosdyn.api.spot_cam.CompositorService/GetIrColormap",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CompositorServiceServer).GetIrColormap(ctx, req.(*GetIrColormapRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CompositorService_SetIrMeterOverlay_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetIrMeterOverlayRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CompositorServiceServer).SetIrMeterOverlay(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bosdyn.api.spot_cam.CompositorService/SetIrMeterOverlay",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CompositorServiceServer).SetIrMeterOverlay(ctx, req.(*SetIrMeterOverlayRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// CompositorService_ServiceDesc is the grpc.ServiceDesc for CompositorService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CompositorService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "bosdyn.api.spot_cam.CompositorService",
	HandlerType: (*CompositorServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SetScreen",
			Handler:    _CompositorService_SetScreen_Handler,
		},
		{
			MethodName: "GetScreen",
			Handler:    _CompositorService_GetScreen_Handler,
		},
		{
			MethodName: "ListScreens",
			Handler:    _CompositorService_ListScreens_Handler,
		},
		{
			MethodName: "GetVisibleCameras",
			Handler:    _CompositorService_GetVisibleCameras_Handler,
		},
		{
			MethodName: "SetIrColormap",
			Handler:    _CompositorService_SetIrColormap_Handler,
		},
		{
			MethodName: "GetIrColormap",
			Handler:    _CompositorService_GetIrColormap_Handler,
		},
		{
			MethodName: "SetIrMeterOverlay",
			Handler:    _CompositorService_SetIrMeterOverlay_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "bosdyn/api/spot_cam/service.proto",
}

// StreamQualityServiceClient is the client API for StreamQualityService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type StreamQualityServiceClient interface {
	SetStreamParams(ctx context.Context, in *SetStreamParamsRequest, opts ...grpc.CallOption) (*SetStreamParamsResponse, error)
	GetStreamParams(ctx context.Context, in *GetStreamParamsRequest, opts ...grpc.CallOption) (*GetStreamParamsResponse, error)
	EnableCongestionControl(ctx context.Context, in *EnableCongestionControlRequest, opts ...grpc.CallOption) (*EnableCongestionControlResponse, error)
}

type streamQualityServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewStreamQualityServiceClient(cc grpc.ClientConnInterface) StreamQualityServiceClient {
	return &streamQualityServiceClient{cc}
}

func (c *streamQualityServiceClient) SetStreamParams(ctx context.Context, in *SetStreamParamsRequest, opts ...grpc.CallOption) (*SetStreamParamsResponse, error) {
	out := new(SetStreamParamsResponse)
	err := c.cc.Invoke(ctx, "/bosdyn.api.spot_cam.StreamQualityService/SetStreamParams", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *streamQualityServiceClient) GetStreamParams(ctx context.Context, in *GetStreamParamsRequest, opts ...grpc.CallOption) (*GetStreamParamsResponse, error) {
	out := new(GetStreamParamsResponse)
	err := c.cc.Invoke(ctx, "/bosdyn.api.spot_cam.StreamQualityService/GetStreamParams", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *streamQualityServiceClient) EnableCongestionControl(ctx context.Context, in *EnableCongestionControlRequest, opts ...grpc.CallOption) (*EnableCongestionControlResponse, error) {
	out := new(EnableCongestionControlResponse)
	err := c.cc.Invoke(ctx, "/bosdyn.api.spot_cam.StreamQualityService/EnableCongestionControl", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// StreamQualityServiceServer is the server API for StreamQualityService service.
// All implementations must embed UnimplementedStreamQualityServiceServer
// for forward compatibility
type StreamQualityServiceServer interface {
	SetStreamParams(context.Context, *SetStreamParamsRequest) (*SetStreamParamsResponse, error)
	GetStreamParams(context.Context, *GetStreamParamsRequest) (*GetStreamParamsResponse, error)
	EnableCongestionControl(context.Context, *EnableCongestionControlRequest) (*EnableCongestionControlResponse, error)
	mustEmbedUnimplementedStreamQualityServiceServer()
}

// UnimplementedStreamQualityServiceServer must be embedded to have forward compatible implementations.
type UnimplementedStreamQualityServiceServer struct {
}

func (UnimplementedStreamQualityServiceServer) SetStreamParams(context.Context, *SetStreamParamsRequest) (*SetStreamParamsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetStreamParams not implemented")
}
func (UnimplementedStreamQualityServiceServer) GetStreamParams(context.Context, *GetStreamParamsRequest) (*GetStreamParamsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetStreamParams not implemented")
}
func (UnimplementedStreamQualityServiceServer) EnableCongestionControl(context.Context, *EnableCongestionControlRequest) (*EnableCongestionControlResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EnableCongestionControl not implemented")
}
func (UnimplementedStreamQualityServiceServer) mustEmbedUnimplementedStreamQualityServiceServer() {}

// UnsafeStreamQualityServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to StreamQualityServiceServer will
// result in compilation errors.
type UnsafeStreamQualityServiceServer interface {
	mustEmbedUnimplementedStreamQualityServiceServer()
}

func RegisterStreamQualityServiceServer(s grpc.ServiceRegistrar, srv StreamQualityServiceServer) {
	s.RegisterService(&StreamQualityService_ServiceDesc, srv)
}

func _StreamQualityService_SetStreamParams_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetStreamParamsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StreamQualityServiceServer).SetStreamParams(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bosdyn.api.spot_cam.StreamQualityService/SetStreamParams",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StreamQualityServiceServer).SetStreamParams(ctx, req.(*SetStreamParamsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StreamQualityService_GetStreamParams_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetStreamParamsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StreamQualityServiceServer).GetStreamParams(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bosdyn.api.spot_cam.StreamQualityService/GetStreamParams",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StreamQualityServiceServer).GetStreamParams(ctx, req.(*GetStreamParamsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StreamQualityService_EnableCongestionControl_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EnableCongestionControlRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StreamQualityServiceServer).EnableCongestionControl(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bosdyn.api.spot_cam.StreamQualityService/EnableCongestionControl",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StreamQualityServiceServer).EnableCongestionControl(ctx, req.(*EnableCongestionControlRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// StreamQualityService_ServiceDesc is the grpc.ServiceDesc for StreamQualityService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var StreamQualityService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "bosdyn.api.spot_cam.StreamQualityService",
	HandlerType: (*StreamQualityServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SetStreamParams",
			Handler:    _StreamQualityService_SetStreamParams_Handler,
		},
		{
			MethodName: "GetStreamParams",
			Handler:    _StreamQualityService_GetStreamParams_Handler,
		},
		{
			MethodName: "EnableCongestionControl",
			Handler:    _StreamQualityService_EnableCongestionControl_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "bosdyn/api/spot_cam/service.proto",
}

// PowerServiceClient is the client API for PowerService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type PowerServiceClient interface {
	// Turn components' power on or off. This should not be used to power cycle a component
	// Turning PTZ power off for too long will cause the video stream to fail
	SetPowerStatus(ctx context.Context, in *SetPowerStatusRequest, opts ...grpc.CallOption) (*SetPowerStatusResponse, error)
	// Get current status of a component
	GetPowerStatus(ctx context.Context, in *GetPowerStatusRequest, opts ...grpc.CallOption) (*GetPowerStatusResponse, error)
	// Cycle power for a component
	CyclePower(ctx context.Context, in *CyclePowerRequest, opts ...grpc.CallOption) (*CyclePowerResponse, error)
}

type powerServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewPowerServiceClient(cc grpc.ClientConnInterface) PowerServiceClient {
	return &powerServiceClient{cc}
}

func (c *powerServiceClient) SetPowerStatus(ctx context.Context, in *SetPowerStatusRequest, opts ...grpc.CallOption) (*SetPowerStatusResponse, error) {
	out := new(SetPowerStatusResponse)
	err := c.cc.Invoke(ctx, "/bosdyn.api.spot_cam.PowerService/SetPowerStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *powerServiceClient) GetPowerStatus(ctx context.Context, in *GetPowerStatusRequest, opts ...grpc.CallOption) (*GetPowerStatusResponse, error) {
	out := new(GetPowerStatusResponse)
	err := c.cc.Invoke(ctx, "/bosdyn.api.spot_cam.PowerService/GetPowerStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *powerServiceClient) CyclePower(ctx context.Context, in *CyclePowerRequest, opts ...grpc.CallOption) (*CyclePowerResponse, error) {
	out := new(CyclePowerResponse)
	err := c.cc.Invoke(ctx, "/bosdyn.api.spot_cam.PowerService/CyclePower", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PowerServiceServer is the server API for PowerService service.
// All implementations must embed UnimplementedPowerServiceServer
// for forward compatibility
type PowerServiceServer interface {
	// Turn components' power on or off. This should not be used to power cycle a component
	// Turning PTZ power off for too long will cause the video stream to fail
	SetPowerStatus(context.Context, *SetPowerStatusRequest) (*SetPowerStatusResponse, error)
	// Get current status of a component
	GetPowerStatus(context.Context, *GetPowerStatusRequest) (*GetPowerStatusResponse, error)
	// Cycle power for a component
	CyclePower(context.Context, *CyclePowerRequest) (*CyclePowerResponse, error)
	mustEmbedUnimplementedPowerServiceServer()
}

// UnimplementedPowerServiceServer must be embedded to have forward compatible implementations.
type UnimplementedPowerServiceServer struct {
}

func (UnimplementedPowerServiceServer) SetPowerStatus(context.Context, *SetPowerStatusRequest) (*SetPowerStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetPowerStatus not implemented")
}
func (UnimplementedPowerServiceServer) GetPowerStatus(context.Context, *GetPowerStatusRequest) (*GetPowerStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPowerStatus not implemented")
}
func (UnimplementedPowerServiceServer) CyclePower(context.Context, *CyclePowerRequest) (*CyclePowerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CyclePower not implemented")
}
func (UnimplementedPowerServiceServer) mustEmbedUnimplementedPowerServiceServer() {}

// UnsafePowerServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PowerServiceServer will
// result in compilation errors.
type UnsafePowerServiceServer interface {
	mustEmbedUnimplementedPowerServiceServer()
}

func RegisterPowerServiceServer(s grpc.ServiceRegistrar, srv PowerServiceServer) {
	s.RegisterService(&PowerService_ServiceDesc, srv)
}

func _PowerService_SetPowerStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetPowerStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PowerServiceServer).SetPowerStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bosdyn.api.spot_cam.PowerService/SetPowerStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PowerServiceServer).SetPowerStatus(ctx, req.(*SetPowerStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PowerService_GetPowerStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPowerStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PowerServiceServer).GetPowerStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bosdyn.api.spot_cam.PowerService/GetPowerStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PowerServiceServer).GetPowerStatus(ctx, req.(*GetPowerStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PowerService_CyclePower_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CyclePowerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PowerServiceServer).CyclePower(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bosdyn.api.spot_cam.PowerService/CyclePower",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PowerServiceServer).CyclePower(ctx, req.(*CyclePowerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// PowerService_ServiceDesc is the grpc.ServiceDesc for PowerService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var PowerService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "bosdyn.api.spot_cam.PowerService",
	HandlerType: (*PowerServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SetPowerStatus",
			Handler:    _PowerService_SetPowerStatus_Handler,
		},
		{
			MethodName: "GetPowerStatus",
			Handler:    _PowerService_GetPowerStatus_Handler,
		},
		{
			MethodName: "CyclePower",
			Handler:    _PowerService_CyclePower_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "bosdyn/api/spot_cam/service.proto",
}

// LightingServiceClient is the client API for LightingService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type LightingServiceClient interface {
	SetLEDBrightness(ctx context.Context, in *SetLEDBrightnessRequest, opts ...grpc.CallOption) (*SetLEDBrightnessResponse, error)
	GetLEDBrightness(ctx context.Context, in *GetLEDBrightnessRequest, opts ...grpc.CallOption) (*GetLEDBrightnessResponse, error)
}

type lightingServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewLightingServiceClient(cc grpc.ClientConnInterface) LightingServiceClient {
	return &lightingServiceClient{cc}
}

func (c *lightingServiceClient) SetLEDBrightness(ctx context.Context, in *SetLEDBrightnessRequest, opts ...grpc.CallOption) (*SetLEDBrightnessResponse, error) {
	out := new(SetLEDBrightnessResponse)
	err := c.cc.Invoke(ctx, "/bosdyn.api.spot_cam.LightingService/SetLEDBrightness", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lightingServiceClient) GetLEDBrightness(ctx context.Context, in *GetLEDBrightnessRequest, opts ...grpc.CallOption) (*GetLEDBrightnessResponse, error) {
	out := new(GetLEDBrightnessResponse)
	err := c.cc.Invoke(ctx, "/bosdyn.api.spot_cam.LightingService/GetLEDBrightness", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// LightingServiceServer is the server API for LightingService service.
// All implementations must embed UnimplementedLightingServiceServer
// for forward compatibility
type LightingServiceServer interface {
	SetLEDBrightness(context.Context, *SetLEDBrightnessRequest) (*SetLEDBrightnessResponse, error)
	GetLEDBrightness(context.Context, *GetLEDBrightnessRequest) (*GetLEDBrightnessResponse, error)
	mustEmbedUnimplementedLightingServiceServer()
}

// UnimplementedLightingServiceServer must be embedded to have forward compatible implementations.
type UnimplementedLightingServiceServer struct {
}

func (UnimplementedLightingServiceServer) SetLEDBrightness(context.Context, *SetLEDBrightnessRequest) (*SetLEDBrightnessResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetLEDBrightness not implemented")
}
func (UnimplementedLightingServiceServer) GetLEDBrightness(context.Context, *GetLEDBrightnessRequest) (*GetLEDBrightnessResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLEDBrightness not implemented")
}
func (UnimplementedLightingServiceServer) mustEmbedUnimplementedLightingServiceServer() {}

// UnsafeLightingServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to LightingServiceServer will
// result in compilation errors.
type UnsafeLightingServiceServer interface {
	mustEmbedUnimplementedLightingServiceServer()
}

func RegisterLightingServiceServer(s grpc.ServiceRegistrar, srv LightingServiceServer) {
	s.RegisterService(&LightingService_ServiceDesc, srv)
}

func _LightingService_SetLEDBrightness_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetLEDBrightnessRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LightingServiceServer).SetLEDBrightness(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bosdyn.api.spot_cam.LightingService/SetLEDBrightness",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LightingServiceServer).SetLEDBrightness(ctx, req.(*SetLEDBrightnessRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LightingService_GetLEDBrightness_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLEDBrightnessRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LightingServiceServer).GetLEDBrightness(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bosdyn.api.spot_cam.LightingService/GetLEDBrightness",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LightingServiceServer).GetLEDBrightness(ctx, req.(*GetLEDBrightnessRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// LightingService_ServiceDesc is the grpc.ServiceDesc for LightingService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var LightingService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "bosdyn.api.spot_cam.LightingService",
	HandlerType: (*LightingServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SetLEDBrightness",
			Handler:    _LightingService_SetLEDBrightness_Handler,
		},
		{
			MethodName: "GetLEDBrightness",
			Handler:    _LightingService_GetLEDBrightness_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "bosdyn/api/spot_cam/service.proto",
}

// MediaLogServiceClient is the client API for MediaLogService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type MediaLogServiceClient interface {
	//Store queues up a Logpoint, which is a bit of media that the user wishes to store to disk
	//(still images are supported for now, more media types will be supported in the future)
	Store(ctx context.Context, in *StoreRequest, opts ...grpc.CallOption) (*StoreResponse, error)
	//GetStatus reads the 'name' field of the Logpoint contained in GetStatusRequest, and fills in
	//the rest of the fields. Mainly useful for getting the 'state' of the logpoint.
	GetStatus(ctx context.Context, in *GetStatusRequest, opts ...grpc.CallOption) (*GetStatusResponse, error)
	//Tag updates the 'tag' field of the Logpoint that's passed, which must exist.
	Tag(ctx context.Context, in *TagRequest, opts ...grpc.CallOption) (*TagResponse, error)
	//EnableDebug starts the periodic logging of health data to the database; this increases disk utilization, but will record data that is useful post-mortum
	EnableDebug(ctx context.Context, in *DebugRequest, opts ...grpc.CallOption) (*DebugResponse, error)
	//ListCameras returns a list of strings that identify valid cameras for logging
	ListCameras(ctx context.Context, in *ListCamerasRequest, opts ...grpc.CallOption) (*ListCamerasResponse, error)
	//Retrieve returns all raw data associated with a given logpoint
	RetrieveRawData(ctx context.Context, in *RetrieveRawDataRequest, opts ...grpc.CallOption) (MediaLogService_RetrieveRawDataClient, error)
	//Retrieve returns all data associated with a given logpoint
	Retrieve(ctx context.Context, in *RetrieveRequest, opts ...grpc.CallOption) (MediaLogService_RetrieveClient, error)
	//Delete removes a Logpoint from the system
	Delete(ctx context.Context, in *DeleteRequest, opts ...grpc.CallOption) (*DeleteResponse, error)
	//ListLogpoints returns a list of all logpoints in the database.
	//Warning: this may be a lot of data.
	ListLogpoints(ctx context.Context, in *ListLogpointsRequest, opts ...grpc.CallOption) (MediaLogService_ListLogpointsClient, error)
	//SetPassphrase sets the eCryptFS passphrase used by the filesystem.
	//there is no symmetry here, because key material is write-only
	//This rpc is now deprecated as of the switch from EXT4 to NTFS and returns UnimplementedError
	SetPassphrase(ctx context.Context, in *SetPassphraseRequest, opts ...grpc.CallOption) (*SetPassphraseResponse, error)
}

type mediaLogServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMediaLogServiceClient(cc grpc.ClientConnInterface) MediaLogServiceClient {
	return &mediaLogServiceClient{cc}
}

func (c *mediaLogServiceClient) Store(ctx context.Context, in *StoreRequest, opts ...grpc.CallOption) (*StoreResponse, error) {
	out := new(StoreResponse)
	err := c.cc.Invoke(ctx, "/bosdyn.api.spot_cam.MediaLogService/Store", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mediaLogServiceClient) GetStatus(ctx context.Context, in *GetStatusRequest, opts ...grpc.CallOption) (*GetStatusResponse, error) {
	out := new(GetStatusResponse)
	err := c.cc.Invoke(ctx, "/bosdyn.api.spot_cam.MediaLogService/GetStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mediaLogServiceClient) Tag(ctx context.Context, in *TagRequest, opts ...grpc.CallOption) (*TagResponse, error) {
	out := new(TagResponse)
	err := c.cc.Invoke(ctx, "/bosdyn.api.spot_cam.MediaLogService/Tag", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mediaLogServiceClient) EnableDebug(ctx context.Context, in *DebugRequest, opts ...grpc.CallOption) (*DebugResponse, error) {
	out := new(DebugResponse)
	err := c.cc.Invoke(ctx, "/bosdyn.api.spot_cam.MediaLogService/EnableDebug", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mediaLogServiceClient) ListCameras(ctx context.Context, in *ListCamerasRequest, opts ...grpc.CallOption) (*ListCamerasResponse, error) {
	out := new(ListCamerasResponse)
	err := c.cc.Invoke(ctx, "/bosdyn.api.spot_cam.MediaLogService/ListCameras", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mediaLogServiceClient) RetrieveRawData(ctx context.Context, in *RetrieveRawDataRequest, opts ...grpc.CallOption) (MediaLogService_RetrieveRawDataClient, error) {
	stream, err := c.cc.NewStream(ctx, &MediaLogService_ServiceDesc.Streams[0], "/bosdyn.api.spot_cam.MediaLogService/RetrieveRawData", opts...)
	if err != nil {
		return nil, err
	}
	x := &mediaLogServiceRetrieveRawDataClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type MediaLogService_RetrieveRawDataClient interface {
	Recv() (*RetrieveRawDataResponse, error)
	grpc.ClientStream
}

type mediaLogServiceRetrieveRawDataClient struct {
	grpc.ClientStream
}

func (x *mediaLogServiceRetrieveRawDataClient) Recv() (*RetrieveRawDataResponse, error) {
	m := new(RetrieveRawDataResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *mediaLogServiceClient) Retrieve(ctx context.Context, in *RetrieveRequest, opts ...grpc.CallOption) (MediaLogService_RetrieveClient, error) {
	stream, err := c.cc.NewStream(ctx, &MediaLogService_ServiceDesc.Streams[1], "/bosdyn.api.spot_cam.MediaLogService/Retrieve", opts...)
	if err != nil {
		return nil, err
	}
	x := &mediaLogServiceRetrieveClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type MediaLogService_RetrieveClient interface {
	Recv() (*RetrieveResponse, error)
	grpc.ClientStream
}

type mediaLogServiceRetrieveClient struct {
	grpc.ClientStream
}

func (x *mediaLogServiceRetrieveClient) Recv() (*RetrieveResponse, error) {
	m := new(RetrieveResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *mediaLogServiceClient) Delete(ctx context.Context, in *DeleteRequest, opts ...grpc.CallOption) (*DeleteResponse, error) {
	out := new(DeleteResponse)
	err := c.cc.Invoke(ctx, "/bosdyn.api.spot_cam.MediaLogService/Delete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mediaLogServiceClient) ListLogpoints(ctx context.Context, in *ListLogpointsRequest, opts ...grpc.CallOption) (MediaLogService_ListLogpointsClient, error) {
	stream, err := c.cc.NewStream(ctx, &MediaLogService_ServiceDesc.Streams[2], "/bosdyn.api.spot_cam.MediaLogService/ListLogpoints", opts...)
	if err != nil {
		return nil, err
	}
	x := &mediaLogServiceListLogpointsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type MediaLogService_ListLogpointsClient interface {
	Recv() (*ListLogpointsResponse, error)
	grpc.ClientStream
}

type mediaLogServiceListLogpointsClient struct {
	grpc.ClientStream
}

func (x *mediaLogServiceListLogpointsClient) Recv() (*ListLogpointsResponse, error) {
	m := new(ListLogpointsResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *mediaLogServiceClient) SetPassphrase(ctx context.Context, in *SetPassphraseRequest, opts ...grpc.CallOption) (*SetPassphraseResponse, error) {
	out := new(SetPassphraseResponse)
	err := c.cc.Invoke(ctx, "/bosdyn.api.spot_cam.MediaLogService/SetPassphrase", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MediaLogServiceServer is the server API for MediaLogService service.
// All implementations must embed UnimplementedMediaLogServiceServer
// for forward compatibility
type MediaLogServiceServer interface {
	//Store queues up a Logpoint, which is a bit of media that the user wishes to store to disk
	//(still images are supported for now, more media types will be supported in the future)
	Store(context.Context, *StoreRequest) (*StoreResponse, error)
	//GetStatus reads the 'name' field of the Logpoint contained in GetStatusRequest, and fills in
	//the rest of the fields. Mainly useful for getting the 'state' of the logpoint.
	GetStatus(context.Context, *GetStatusRequest) (*GetStatusResponse, error)
	//Tag updates the 'tag' field of the Logpoint that's passed, which must exist.
	Tag(context.Context, *TagRequest) (*TagResponse, error)
	//EnableDebug starts the periodic logging of health data to the database; this increases disk utilization, but will record data that is useful post-mortum
	EnableDebug(context.Context, *DebugRequest) (*DebugResponse, error)
	//ListCameras returns a list of strings that identify valid cameras for logging
	ListCameras(context.Context, *ListCamerasRequest) (*ListCamerasResponse, error)
	//Retrieve returns all raw data associated with a given logpoint
	RetrieveRawData(*RetrieveRawDataRequest, MediaLogService_RetrieveRawDataServer) error
	//Retrieve returns all data associated with a given logpoint
	Retrieve(*RetrieveRequest, MediaLogService_RetrieveServer) error
	//Delete removes a Logpoint from the system
	Delete(context.Context, *DeleteRequest) (*DeleteResponse, error)
	//ListLogpoints returns a list of all logpoints in the database.
	//Warning: this may be a lot of data.
	ListLogpoints(*ListLogpointsRequest, MediaLogService_ListLogpointsServer) error
	//SetPassphrase sets the eCryptFS passphrase used by the filesystem.
	//there is no symmetry here, because key material is write-only
	//This rpc is now deprecated as of the switch from EXT4 to NTFS and returns UnimplementedError
	SetPassphrase(context.Context, *SetPassphraseRequest) (*SetPassphraseResponse, error)
	mustEmbedUnimplementedMediaLogServiceServer()
}

// UnimplementedMediaLogServiceServer must be embedded to have forward compatible implementations.
type UnimplementedMediaLogServiceServer struct {
}

func (UnimplementedMediaLogServiceServer) Store(context.Context, *StoreRequest) (*StoreResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Store not implemented")
}
func (UnimplementedMediaLogServiceServer) GetStatus(context.Context, *GetStatusRequest) (*GetStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetStatus not implemented")
}
func (UnimplementedMediaLogServiceServer) Tag(context.Context, *TagRequest) (*TagResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Tag not implemented")
}
func (UnimplementedMediaLogServiceServer) EnableDebug(context.Context, *DebugRequest) (*DebugResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EnableDebug not implemented")
}
func (UnimplementedMediaLogServiceServer) ListCameras(context.Context, *ListCamerasRequest) (*ListCamerasResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListCameras not implemented")
}
func (UnimplementedMediaLogServiceServer) RetrieveRawData(*RetrieveRawDataRequest, MediaLogService_RetrieveRawDataServer) error {
	return status.Errorf(codes.Unimplemented, "method RetrieveRawData not implemented")
}
func (UnimplementedMediaLogServiceServer) Retrieve(*RetrieveRequest, MediaLogService_RetrieveServer) error {
	return status.Errorf(codes.Unimplemented, "method Retrieve not implemented")
}
func (UnimplementedMediaLogServiceServer) Delete(context.Context, *DeleteRequest) (*DeleteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedMediaLogServiceServer) ListLogpoints(*ListLogpointsRequest, MediaLogService_ListLogpointsServer) error {
	return status.Errorf(codes.Unimplemented, "method ListLogpoints not implemented")
}
func (UnimplementedMediaLogServiceServer) SetPassphrase(context.Context, *SetPassphraseRequest) (*SetPassphraseResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetPassphrase not implemented")
}
func (UnimplementedMediaLogServiceServer) mustEmbedUnimplementedMediaLogServiceServer() {}

// UnsafeMediaLogServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MediaLogServiceServer will
// result in compilation errors.
type UnsafeMediaLogServiceServer interface {
	mustEmbedUnimplementedMediaLogServiceServer()
}

func RegisterMediaLogServiceServer(s grpc.ServiceRegistrar, srv MediaLogServiceServer) {
	s.RegisterService(&MediaLogService_ServiceDesc, srv)
}

func _MediaLogService_Store_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StoreRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MediaLogServiceServer).Store(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bosdyn.api.spot_cam.MediaLogService/Store",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MediaLogServiceServer).Store(ctx, req.(*StoreRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MediaLogService_GetStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MediaLogServiceServer).GetStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bosdyn.api.spot_cam.MediaLogService/GetStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MediaLogServiceServer).GetStatus(ctx, req.(*GetStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MediaLogService_Tag_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TagRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MediaLogServiceServer).Tag(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bosdyn.api.spot_cam.MediaLogService/Tag",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MediaLogServiceServer).Tag(ctx, req.(*TagRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MediaLogService_EnableDebug_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DebugRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MediaLogServiceServer).EnableDebug(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bosdyn.api.spot_cam.MediaLogService/EnableDebug",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MediaLogServiceServer).EnableDebug(ctx, req.(*DebugRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MediaLogService_ListCameras_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListCamerasRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MediaLogServiceServer).ListCameras(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bosdyn.api.spot_cam.MediaLogService/ListCameras",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MediaLogServiceServer).ListCameras(ctx, req.(*ListCamerasRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MediaLogService_RetrieveRawData_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(RetrieveRawDataRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(MediaLogServiceServer).RetrieveRawData(m, &mediaLogServiceRetrieveRawDataServer{stream})
}

type MediaLogService_RetrieveRawDataServer interface {
	Send(*RetrieveRawDataResponse) error
	grpc.ServerStream
}

type mediaLogServiceRetrieveRawDataServer struct {
	grpc.ServerStream
}

func (x *mediaLogServiceRetrieveRawDataServer) Send(m *RetrieveRawDataResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _MediaLogService_Retrieve_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(RetrieveRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(MediaLogServiceServer).Retrieve(m, &mediaLogServiceRetrieveServer{stream})
}

type MediaLogService_RetrieveServer interface {
	Send(*RetrieveResponse) error
	grpc.ServerStream
}

type mediaLogServiceRetrieveServer struct {
	grpc.ServerStream
}

func (x *mediaLogServiceRetrieveServer) Send(m *RetrieveResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _MediaLogService_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MediaLogServiceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bosdyn.api.spot_cam.MediaLogService/Delete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MediaLogServiceServer).Delete(ctx, req.(*DeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MediaLogService_ListLogpoints_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ListLogpointsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(MediaLogServiceServer).ListLogpoints(m, &mediaLogServiceListLogpointsServer{stream})
}

type MediaLogService_ListLogpointsServer interface {
	Send(*ListLogpointsResponse) error
	grpc.ServerStream
}

type mediaLogServiceListLogpointsServer struct {
	grpc.ServerStream
}

func (x *mediaLogServiceListLogpointsServer) Send(m *ListLogpointsResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _MediaLogService_SetPassphrase_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetPassphraseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MediaLogServiceServer).SetPassphrase(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bosdyn.api.spot_cam.MediaLogService/SetPassphrase",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MediaLogServiceServer).SetPassphrase(ctx, req.(*SetPassphraseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// MediaLogService_ServiceDesc is the grpc.ServiceDesc for MediaLogService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var MediaLogService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "bosdyn.api.spot_cam.MediaLogService",
	HandlerType: (*MediaLogServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Store",
			Handler:    _MediaLogService_Store_Handler,
		},
		{
			MethodName: "GetStatus",
			Handler:    _MediaLogService_GetStatus_Handler,
		},
		{
			MethodName: "Tag",
			Handler:    _MediaLogService_Tag_Handler,
		},
		{
			MethodName: "EnableDebug",
			Handler:    _MediaLogService_EnableDebug_Handler,
		},
		{
			MethodName: "ListCameras",
			Handler:    _MediaLogService_ListCameras_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _MediaLogService_Delete_Handler,
		},
		{
			MethodName: "SetPassphrase",
			Handler:    _MediaLogService_SetPassphrase_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "RetrieveRawData",
			Handler:       _MediaLogService_RetrieveRawData_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "Retrieve",
			Handler:       _MediaLogService_Retrieve_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ListLogpoints",
			Handler:       _MediaLogService_ListLogpoints_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "bosdyn/api/spot_cam/service.proto",
}

// PtzServiceClient is the client API for PtzService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type PtzServiceClient interface {
	//SetPosition points the referenced camera to a given vector (in PTZ-space)
	SetPtzPosition(ctx context.Context, in *SetPtzPositionRequest, opts ...grpc.CallOption) (*SetPtzPositionResponse, error)
	//GetPosition returns the current settings of the referenced camera
	GetPtzPosition(ctx context.Context, in *GetPtzPositionRequest, opts ...grpc.CallOption) (*GetPtzPositionResponse, error)
	SetPtzVelocity(ctx context.Context, in *SetPtzVelocityRequest, opts ...grpc.CallOption) (*SetPtzVelocityResponse, error)
	GetPtzVelocity(ctx context.Context, in *GetPtzVelocityRequest, opts ...grpc.CallOption) (*GetPtzVelocityResponse, error)
	ListPtz(ctx context.Context, in *ListPtzRequest, opts ...grpc.CallOption) (*ListPtzResponse, error)
	// Reinitializes PTZ autofocus
	InitializeLens(ctx context.Context, in *InitializeLensRequest, opts ...grpc.CallOption) (*InitializeLensResponse, error)
}

type ptzServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewPtzServiceClient(cc grpc.ClientConnInterface) PtzServiceClient {
	return &ptzServiceClient{cc}
}

func (c *ptzServiceClient) SetPtzPosition(ctx context.Context, in *SetPtzPositionRequest, opts ...grpc.CallOption) (*SetPtzPositionResponse, error) {
	out := new(SetPtzPositionResponse)
	err := c.cc.Invoke(ctx, "/bosdyn.api.spot_cam.PtzService/SetPtzPosition", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ptzServiceClient) GetPtzPosition(ctx context.Context, in *GetPtzPositionRequest, opts ...grpc.CallOption) (*GetPtzPositionResponse, error) {
	out := new(GetPtzPositionResponse)
	err := c.cc.Invoke(ctx, "/bosdyn.api.spot_cam.PtzService/GetPtzPosition", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ptzServiceClient) SetPtzVelocity(ctx context.Context, in *SetPtzVelocityRequest, opts ...grpc.CallOption) (*SetPtzVelocityResponse, error) {
	out := new(SetPtzVelocityResponse)
	err := c.cc.Invoke(ctx, "/bosdyn.api.spot_cam.PtzService/SetPtzVelocity", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ptzServiceClient) GetPtzVelocity(ctx context.Context, in *GetPtzVelocityRequest, opts ...grpc.CallOption) (*GetPtzVelocityResponse, error) {
	out := new(GetPtzVelocityResponse)
	err := c.cc.Invoke(ctx, "/bosdyn.api.spot_cam.PtzService/GetPtzVelocity", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ptzServiceClient) ListPtz(ctx context.Context, in *ListPtzRequest, opts ...grpc.CallOption) (*ListPtzResponse, error) {
	out := new(ListPtzResponse)
	err := c.cc.Invoke(ctx, "/bosdyn.api.spot_cam.PtzService/ListPtz", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ptzServiceClient) InitializeLens(ctx context.Context, in *InitializeLensRequest, opts ...grpc.CallOption) (*InitializeLensResponse, error) {
	out := new(InitializeLensResponse)
	err := c.cc.Invoke(ctx, "/bosdyn.api.spot_cam.PtzService/InitializeLens", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PtzServiceServer is the server API for PtzService service.
// All implementations must embed UnimplementedPtzServiceServer
// for forward compatibility
type PtzServiceServer interface {
	//SetPosition points the referenced camera to a given vector (in PTZ-space)
	SetPtzPosition(context.Context, *SetPtzPositionRequest) (*SetPtzPositionResponse, error)
	//GetPosition returns the current settings of the referenced camera
	GetPtzPosition(context.Context, *GetPtzPositionRequest) (*GetPtzPositionResponse, error)
	SetPtzVelocity(context.Context, *SetPtzVelocityRequest) (*SetPtzVelocityResponse, error)
	GetPtzVelocity(context.Context, *GetPtzVelocityRequest) (*GetPtzVelocityResponse, error)
	ListPtz(context.Context, *ListPtzRequest) (*ListPtzResponse, error)
	// Reinitializes PTZ autofocus
	InitializeLens(context.Context, *InitializeLensRequest) (*InitializeLensResponse, error)
	mustEmbedUnimplementedPtzServiceServer()
}

// UnimplementedPtzServiceServer must be embedded to have forward compatible implementations.
type UnimplementedPtzServiceServer struct {
}

func (UnimplementedPtzServiceServer) SetPtzPosition(context.Context, *SetPtzPositionRequest) (*SetPtzPositionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetPtzPosition not implemented")
}
func (UnimplementedPtzServiceServer) GetPtzPosition(context.Context, *GetPtzPositionRequest) (*GetPtzPositionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPtzPosition not implemented")
}
func (UnimplementedPtzServiceServer) SetPtzVelocity(context.Context, *SetPtzVelocityRequest) (*SetPtzVelocityResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetPtzVelocity not implemented")
}
func (UnimplementedPtzServiceServer) GetPtzVelocity(context.Context, *GetPtzVelocityRequest) (*GetPtzVelocityResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPtzVelocity not implemented")
}
func (UnimplementedPtzServiceServer) ListPtz(context.Context, *ListPtzRequest) (*ListPtzResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListPtz not implemented")
}
func (UnimplementedPtzServiceServer) InitializeLens(context.Context, *InitializeLensRequest) (*InitializeLensResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InitializeLens not implemented")
}
func (UnimplementedPtzServiceServer) mustEmbedUnimplementedPtzServiceServer() {}

// UnsafePtzServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PtzServiceServer will
// result in compilation errors.
type UnsafePtzServiceServer interface {
	mustEmbedUnimplementedPtzServiceServer()
}

func RegisterPtzServiceServer(s grpc.ServiceRegistrar, srv PtzServiceServer) {
	s.RegisterService(&PtzService_ServiceDesc, srv)
}

func _PtzService_SetPtzPosition_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetPtzPositionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PtzServiceServer).SetPtzPosition(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bosdyn.api.spot_cam.PtzService/SetPtzPosition",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PtzServiceServer).SetPtzPosition(ctx, req.(*SetPtzPositionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PtzService_GetPtzPosition_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPtzPositionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PtzServiceServer).GetPtzPosition(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bosdyn.api.spot_cam.PtzService/GetPtzPosition",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PtzServiceServer).GetPtzPosition(ctx, req.(*GetPtzPositionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PtzService_SetPtzVelocity_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetPtzVelocityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PtzServiceServer).SetPtzVelocity(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bosdyn.api.spot_cam.PtzService/SetPtzVelocity",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PtzServiceServer).SetPtzVelocity(ctx, req.(*SetPtzVelocityRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PtzService_GetPtzVelocity_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPtzVelocityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PtzServiceServer).GetPtzVelocity(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bosdyn.api.spot_cam.PtzService/GetPtzVelocity",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PtzServiceServer).GetPtzVelocity(ctx, req.(*GetPtzVelocityRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PtzService_ListPtz_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListPtzRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PtzServiceServer).ListPtz(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bosdyn.api.spot_cam.PtzService/ListPtz",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PtzServiceServer).ListPtz(ctx, req.(*ListPtzRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PtzService_InitializeLens_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InitializeLensRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PtzServiceServer).InitializeLens(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bosdyn.api.spot_cam.PtzService/InitializeLens",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PtzServiceServer).InitializeLens(ctx, req.(*InitializeLensRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// PtzService_ServiceDesc is the grpc.ServiceDesc for PtzService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var PtzService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "bosdyn.api.spot_cam.PtzService",
	HandlerType: (*PtzServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SetPtzPosition",
			Handler:    _PtzService_SetPtzPosition_Handler,
		},
		{
			MethodName: "GetPtzPosition",
			Handler:    _PtzService_GetPtzPosition_Handler,
		},
		{
			MethodName: "SetPtzVelocity",
			Handler:    _PtzService_SetPtzVelocity_Handler,
		},
		{
			MethodName: "GetPtzVelocity",
			Handler:    _PtzService_GetPtzVelocity_Handler,
		},
		{
			MethodName: "ListPtz",
			Handler:    _PtzService_ListPtz_Handler,
		},
		{
			MethodName: "InitializeLens",
			Handler:    _PtzService_InitializeLens_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "bosdyn/api/spot_cam/service.proto",
}

// AudioServiceClient is the client API for AudioService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AudioServiceClient interface {
	//Given a soundRequest that identifies a single sound present in the system's sound effects table, PlaySound executes the sound effect.
	PlaySound(ctx context.Context, in *PlaySoundRequest, opts ...grpc.CallOption) (*PlaySoundResponse, error)
	//LoadSound loads a sound effect into the system's sound table. The stream must contain a wav file, with a RIFF header describing it.
	//The arguement is a stream, to allow for sounds that are bigger then the MTU of the network; in this case, the complete stream must
	//contain the entire sound. If the stream ends early, an error will be returned. The header and sound fields of the entire stream must
	//be the same.
	LoadSound(ctx context.Context, opts ...grpc.CallOption) (AudioService_LoadSoundClient, error)
	//Delete the sound identified in the argument from the system's sound table.
	DeleteSound(ctx context.Context, in *DeleteSoundRequest, opts ...grpc.CallOption) (*DeleteSoundResponse, error)
	//ListSounds returns a list of all of the sound effects that the system knows about.
	ListSounds(ctx context.Context, in *ListSoundsRequest, opts ...grpc.CallOption) (*ListSoundsResponse, error)
	// Set the overall volume level for playing sounds.
	SetVolume(ctx context.Context, in *SetVolumeRequest, opts ...grpc.CallOption) (*SetVolumeResponse, error)
	// Set the overall volume level for playing sounds.
	GetVolume(ctx context.Context, in *GetVolumeRequest, opts ...grpc.CallOption) (*GetVolumeResponse, error)
	SetAudioCaptureChannel(ctx context.Context, in *SetAudioCaptureChannelRequest, opts ...grpc.CallOption) (*SetAudioCaptureChannelResponse, error)
	GetAudioCaptureChannel(ctx context.Context, in *GetAudioCaptureChannelRequest, opts ...grpc.CallOption) (*GetAudioCaptureChannelResponse, error)
	SetAudioCaptureGain(ctx context.Context, in *SetAudioCaptureGainRequest, opts ...grpc.CallOption) (*SetAudioCaptureGainResponse, error)
	GetAudioCaptureGain(ctx context.Context, in *GetAudioCaptureGainRequest, opts ...grpc.CallOption) (*GetAudioCaptureGainResponse, error)
}

type audioServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewAudioServiceClient(cc grpc.ClientConnInterface) AudioServiceClient {
	return &audioServiceClient{cc}
}

func (c *audioServiceClient) PlaySound(ctx context.Context, in *PlaySoundRequest, opts ...grpc.CallOption) (*PlaySoundResponse, error) {
	out := new(PlaySoundResponse)
	err := c.cc.Invoke(ctx, "/bosdyn.api.spot_cam.AudioService/PlaySound", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *audioServiceClient) LoadSound(ctx context.Context, opts ...grpc.CallOption) (AudioService_LoadSoundClient, error) {
	stream, err := c.cc.NewStream(ctx, &AudioService_ServiceDesc.Streams[0], "/bosdyn.api.spot_cam.AudioService/LoadSound", opts...)
	if err != nil {
		return nil, err
	}
	x := &audioServiceLoadSoundClient{stream}
	return x, nil
}

type AudioService_LoadSoundClient interface {
	Send(*LoadSoundRequest) error
	CloseAndRecv() (*LoadSoundResponse, error)
	grpc.ClientStream
}

type audioServiceLoadSoundClient struct {
	grpc.ClientStream
}

func (x *audioServiceLoadSoundClient) Send(m *LoadSoundRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *audioServiceLoadSoundClient) CloseAndRecv() (*LoadSoundResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(LoadSoundResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *audioServiceClient) DeleteSound(ctx context.Context, in *DeleteSoundRequest, opts ...grpc.CallOption) (*DeleteSoundResponse, error) {
	out := new(DeleteSoundResponse)
	err := c.cc.Invoke(ctx, "/bosdyn.api.spot_cam.AudioService/DeleteSound", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *audioServiceClient) ListSounds(ctx context.Context, in *ListSoundsRequest, opts ...grpc.CallOption) (*ListSoundsResponse, error) {
	out := new(ListSoundsResponse)
	err := c.cc.Invoke(ctx, "/bosdyn.api.spot_cam.AudioService/ListSounds", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *audioServiceClient) SetVolume(ctx context.Context, in *SetVolumeRequest, opts ...grpc.CallOption) (*SetVolumeResponse, error) {
	out := new(SetVolumeResponse)
	err := c.cc.Invoke(ctx, "/bosdyn.api.spot_cam.AudioService/SetVolume", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *audioServiceClient) GetVolume(ctx context.Context, in *GetVolumeRequest, opts ...grpc.CallOption) (*GetVolumeResponse, error) {
	out := new(GetVolumeResponse)
	err := c.cc.Invoke(ctx, "/bosdyn.api.spot_cam.AudioService/GetVolume", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *audioServiceClient) SetAudioCaptureChannel(ctx context.Context, in *SetAudioCaptureChannelRequest, opts ...grpc.CallOption) (*SetAudioCaptureChannelResponse, error) {
	out := new(SetAudioCaptureChannelResponse)
	err := c.cc.Invoke(ctx, "/bosdyn.api.spot_cam.AudioService/SetAudioCaptureChannel", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *audioServiceClient) GetAudioCaptureChannel(ctx context.Context, in *GetAudioCaptureChannelRequest, opts ...grpc.CallOption) (*GetAudioCaptureChannelResponse, error) {
	out := new(GetAudioCaptureChannelResponse)
	err := c.cc.Invoke(ctx, "/bosdyn.api.spot_cam.AudioService/GetAudioCaptureChannel", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *audioServiceClient) SetAudioCaptureGain(ctx context.Context, in *SetAudioCaptureGainRequest, opts ...grpc.CallOption) (*SetAudioCaptureGainResponse, error) {
	out := new(SetAudioCaptureGainResponse)
	err := c.cc.Invoke(ctx, "/bosdyn.api.spot_cam.AudioService/SetAudioCaptureGain", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *audioServiceClient) GetAudioCaptureGain(ctx context.Context, in *GetAudioCaptureGainRequest, opts ...grpc.CallOption) (*GetAudioCaptureGainResponse, error) {
	out := new(GetAudioCaptureGainResponse)
	err := c.cc.Invoke(ctx, "/bosdyn.api.spot_cam.AudioService/GetAudioCaptureGain", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AudioServiceServer is the server API for AudioService service.
// All implementations must embed UnimplementedAudioServiceServer
// for forward compatibility
type AudioServiceServer interface {
	//Given a soundRequest that identifies a single sound present in the system's sound effects table, PlaySound executes the sound effect.
	PlaySound(context.Context, *PlaySoundRequest) (*PlaySoundResponse, error)
	//LoadSound loads a sound effect into the system's sound table. The stream must contain a wav file, with a RIFF header describing it.
	//The arguement is a stream, to allow for sounds that are bigger then the MTU of the network; in this case, the complete stream must
	//contain the entire sound. If the stream ends early, an error will be returned. The header and sound fields of the entire stream must
	//be the same.
	LoadSound(AudioService_LoadSoundServer) error
	//Delete the sound identified in the argument from the system's sound table.
	DeleteSound(context.Context, *DeleteSoundRequest) (*DeleteSoundResponse, error)
	//ListSounds returns a list of all of the sound effects that the system knows about.
	ListSounds(context.Context, *ListSoundsRequest) (*ListSoundsResponse, error)
	// Set the overall volume level for playing sounds.
	SetVolume(context.Context, *SetVolumeRequest) (*SetVolumeResponse, error)
	// Set the overall volume level for playing sounds.
	GetVolume(context.Context, *GetVolumeRequest) (*GetVolumeResponse, error)
	SetAudioCaptureChannel(context.Context, *SetAudioCaptureChannelRequest) (*SetAudioCaptureChannelResponse, error)
	GetAudioCaptureChannel(context.Context, *GetAudioCaptureChannelRequest) (*GetAudioCaptureChannelResponse, error)
	SetAudioCaptureGain(context.Context, *SetAudioCaptureGainRequest) (*SetAudioCaptureGainResponse, error)
	GetAudioCaptureGain(context.Context, *GetAudioCaptureGainRequest) (*GetAudioCaptureGainResponse, error)
	mustEmbedUnimplementedAudioServiceServer()
}

// UnimplementedAudioServiceServer must be embedded to have forward compatible implementations.
type UnimplementedAudioServiceServer struct {
}

func (UnimplementedAudioServiceServer) PlaySound(context.Context, *PlaySoundRequest) (*PlaySoundResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PlaySound not implemented")
}
func (UnimplementedAudioServiceServer) LoadSound(AudioService_LoadSoundServer) error {
	return status.Errorf(codes.Unimplemented, "method LoadSound not implemented")
}
func (UnimplementedAudioServiceServer) DeleteSound(context.Context, *DeleteSoundRequest) (*DeleteSoundResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteSound not implemented")
}
func (UnimplementedAudioServiceServer) ListSounds(context.Context, *ListSoundsRequest) (*ListSoundsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListSounds not implemented")
}
func (UnimplementedAudioServiceServer) SetVolume(context.Context, *SetVolumeRequest) (*SetVolumeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetVolume not implemented")
}
func (UnimplementedAudioServiceServer) GetVolume(context.Context, *GetVolumeRequest) (*GetVolumeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetVolume not implemented")
}
func (UnimplementedAudioServiceServer) SetAudioCaptureChannel(context.Context, *SetAudioCaptureChannelRequest) (*SetAudioCaptureChannelResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetAudioCaptureChannel not implemented")
}
func (UnimplementedAudioServiceServer) GetAudioCaptureChannel(context.Context, *GetAudioCaptureChannelRequest) (*GetAudioCaptureChannelResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAudioCaptureChannel not implemented")
}
func (UnimplementedAudioServiceServer) SetAudioCaptureGain(context.Context, *SetAudioCaptureGainRequest) (*SetAudioCaptureGainResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetAudioCaptureGain not implemented")
}
func (UnimplementedAudioServiceServer) GetAudioCaptureGain(context.Context, *GetAudioCaptureGainRequest) (*GetAudioCaptureGainResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAudioCaptureGain not implemented")
}
func (UnimplementedAudioServiceServer) mustEmbedUnimplementedAudioServiceServer() {}

// UnsafeAudioServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AudioServiceServer will
// result in compilation errors.
type UnsafeAudioServiceServer interface {
	mustEmbedUnimplementedAudioServiceServer()
}

func RegisterAudioServiceServer(s grpc.ServiceRegistrar, srv AudioServiceServer) {
	s.RegisterService(&AudioService_ServiceDesc, srv)
}

func _AudioService_PlaySound_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PlaySoundRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AudioServiceServer).PlaySound(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bosdyn.api.spot_cam.AudioService/PlaySound",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AudioServiceServer).PlaySound(ctx, req.(*PlaySoundRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AudioService_LoadSound_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(AudioServiceServer).LoadSound(&audioServiceLoadSoundServer{stream})
}

type AudioService_LoadSoundServer interface {
	SendAndClose(*LoadSoundResponse) error
	Recv() (*LoadSoundRequest, error)
	grpc.ServerStream
}

type audioServiceLoadSoundServer struct {
	grpc.ServerStream
}

func (x *audioServiceLoadSoundServer) SendAndClose(m *LoadSoundResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *audioServiceLoadSoundServer) Recv() (*LoadSoundRequest, error) {
	m := new(LoadSoundRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _AudioService_DeleteSound_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteSoundRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AudioServiceServer).DeleteSound(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bosdyn.api.spot_cam.AudioService/DeleteSound",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AudioServiceServer).DeleteSound(ctx, req.(*DeleteSoundRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AudioService_ListSounds_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListSoundsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AudioServiceServer).ListSounds(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bosdyn.api.spot_cam.AudioService/ListSounds",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AudioServiceServer).ListSounds(ctx, req.(*ListSoundsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AudioService_SetVolume_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetVolumeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AudioServiceServer).SetVolume(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bosdyn.api.spot_cam.AudioService/SetVolume",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AudioServiceServer).SetVolume(ctx, req.(*SetVolumeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AudioService_GetVolume_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetVolumeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AudioServiceServer).GetVolume(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bosdyn.api.spot_cam.AudioService/GetVolume",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AudioServiceServer).GetVolume(ctx, req.(*GetVolumeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AudioService_SetAudioCaptureChannel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetAudioCaptureChannelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AudioServiceServer).SetAudioCaptureChannel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bosdyn.api.spot_cam.AudioService/SetAudioCaptureChannel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AudioServiceServer).SetAudioCaptureChannel(ctx, req.(*SetAudioCaptureChannelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AudioService_GetAudioCaptureChannel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAudioCaptureChannelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AudioServiceServer).GetAudioCaptureChannel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bosdyn.api.spot_cam.AudioService/GetAudioCaptureChannel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AudioServiceServer).GetAudioCaptureChannel(ctx, req.(*GetAudioCaptureChannelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AudioService_SetAudioCaptureGain_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetAudioCaptureGainRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AudioServiceServer).SetAudioCaptureGain(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bosdyn.api.spot_cam.AudioService/SetAudioCaptureGain",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AudioServiceServer).SetAudioCaptureGain(ctx, req.(*SetAudioCaptureGainRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AudioService_GetAudioCaptureGain_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAudioCaptureGainRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AudioServiceServer).GetAudioCaptureGain(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bosdyn.api.spot_cam.AudioService/GetAudioCaptureGain",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AudioServiceServer).GetAudioCaptureGain(ctx, req.(*GetAudioCaptureGainRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// AudioService_ServiceDesc is the grpc.ServiceDesc for AudioService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AudioService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "bosdyn.api.spot_cam.AudioService",
	HandlerType: (*AudioServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "PlaySound",
			Handler:    _AudioService_PlaySound_Handler,
		},
		{
			MethodName: "DeleteSound",
			Handler:    _AudioService_DeleteSound_Handler,
		},
		{
			MethodName: "ListSounds",
			Handler:    _AudioService_ListSounds_Handler,
		},
		{
			MethodName: "SetVolume",
			Handler:    _AudioService_SetVolume_Handler,
		},
		{
			MethodName: "GetVolume",
			Handler:    _AudioService_GetVolume_Handler,
		},
		{
			MethodName: "SetAudioCaptureChannel",
			Handler:    _AudioService_SetAudioCaptureChannel_Handler,
		},
		{
			MethodName: "GetAudioCaptureChannel",
			Handler:    _AudioService_GetAudioCaptureChannel_Handler,
		},
		{
			MethodName: "SetAudioCaptureGain",
			Handler:    _AudioService_SetAudioCaptureGain_Handler,
		},
		{
			MethodName: "GetAudioCaptureGain",
			Handler:    _AudioService_GetAudioCaptureGain_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "LoadSound",
			Handler:       _AudioService_LoadSound_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "bosdyn/api/spot_cam/service.proto",
}

// HealthServiceClient is the client API for HealthService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type HealthServiceClient interface {
	//GetTemperature returns a list of thermometers in the system, and the temperature that they measure.
	GetTemperature(ctx context.Context, in *GetTemperatureRequest, opts ...grpc.CallOption) (*GetTemperatureResponse, error)
	//GetBitStatus returns two lists; a list of system events, and a list of ways that the system is degraded;
	//for instance, a degredation may include a missing PTZ unit, or a missing USB storage device.
	GetBITStatus(ctx context.Context, in *GetBITStatusRequest, opts ...grpc.CallOption) (*GetBITStatusResponse, error)
	//ClearBitEvents clears out the events list of the BITStatus structure.
	ClearBITEvents(ctx context.Context, in *ClearBITEventsRequest, opts ...grpc.CallOption) (*ClearBITEventsResponse, error)
	//GetSystemLog retrieves an encrypted log of system events, for factory diagnosis of possible issues.
	//The data streamed back should be concatenated to a single file, before sending to the manufacturer.
	GetSystemLog(ctx context.Context, in *GetSystemLogRequest, opts ...grpc.CallOption) (HealthService_GetSystemLogClient, error)
}

type healthServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewHealthServiceClient(cc grpc.ClientConnInterface) HealthServiceClient {
	return &healthServiceClient{cc}
}

func (c *healthServiceClient) GetTemperature(ctx context.Context, in *GetTemperatureRequest, opts ...grpc.CallOption) (*GetTemperatureResponse, error) {
	out := new(GetTemperatureResponse)
	err := c.cc.Invoke(ctx, "/bosdyn.api.spot_cam.HealthService/GetTemperature", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *healthServiceClient) GetBITStatus(ctx context.Context, in *GetBITStatusRequest, opts ...grpc.CallOption) (*GetBITStatusResponse, error) {
	out := new(GetBITStatusResponse)
	err := c.cc.Invoke(ctx, "/bosdyn.api.spot_cam.HealthService/GetBITStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *healthServiceClient) ClearBITEvents(ctx context.Context, in *ClearBITEventsRequest, opts ...grpc.CallOption) (*ClearBITEventsResponse, error) {
	out := new(ClearBITEventsResponse)
	err := c.cc.Invoke(ctx, "/bosdyn.api.spot_cam.HealthService/ClearBITEvents", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *healthServiceClient) GetSystemLog(ctx context.Context, in *GetSystemLogRequest, opts ...grpc.CallOption) (HealthService_GetSystemLogClient, error) {
	stream, err := c.cc.NewStream(ctx, &HealthService_ServiceDesc.Streams[0], "/bosdyn.api.spot_cam.HealthService/GetSystemLog", opts...)
	if err != nil {
		return nil, err
	}
	x := &healthServiceGetSystemLogClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type HealthService_GetSystemLogClient interface {
	Recv() (*GetSystemLogResponse, error)
	grpc.ClientStream
}

type healthServiceGetSystemLogClient struct {
	grpc.ClientStream
}

func (x *healthServiceGetSystemLogClient) Recv() (*GetSystemLogResponse, error) {
	m := new(GetSystemLogResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// HealthServiceServer is the server API for HealthService service.
// All implementations must embed UnimplementedHealthServiceServer
// for forward compatibility
type HealthServiceServer interface {
	//GetTemperature returns a list of thermometers in the system, and the temperature that they measure.
	GetTemperature(context.Context, *GetTemperatureRequest) (*GetTemperatureResponse, error)
	//GetBitStatus returns two lists; a list of system events, and a list of ways that the system is degraded;
	//for instance, a degredation may include a missing PTZ unit, or a missing USB storage device.
	GetBITStatus(context.Context, *GetBITStatusRequest) (*GetBITStatusResponse, error)
	//ClearBitEvents clears out the events list of the BITStatus structure.
	ClearBITEvents(context.Context, *ClearBITEventsRequest) (*ClearBITEventsResponse, error)
	//GetSystemLog retrieves an encrypted log of system events, for factory diagnosis of possible issues.
	//The data streamed back should be concatenated to a single file, before sending to the manufacturer.
	GetSystemLog(*GetSystemLogRequest, HealthService_GetSystemLogServer) error
	mustEmbedUnimplementedHealthServiceServer()
}

// UnimplementedHealthServiceServer must be embedded to have forward compatible implementations.
type UnimplementedHealthServiceServer struct {
}

func (UnimplementedHealthServiceServer) GetTemperature(context.Context, *GetTemperatureRequest) (*GetTemperatureResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTemperature not implemented")
}
func (UnimplementedHealthServiceServer) GetBITStatus(context.Context, *GetBITStatusRequest) (*GetBITStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBITStatus not implemented")
}
func (UnimplementedHealthServiceServer) ClearBITEvents(context.Context, *ClearBITEventsRequest) (*ClearBITEventsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ClearBITEvents not implemented")
}
func (UnimplementedHealthServiceServer) GetSystemLog(*GetSystemLogRequest, HealthService_GetSystemLogServer) error {
	return status.Errorf(codes.Unimplemented, "method GetSystemLog not implemented")
}
func (UnimplementedHealthServiceServer) mustEmbedUnimplementedHealthServiceServer() {}

// UnsafeHealthServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to HealthServiceServer will
// result in compilation errors.
type UnsafeHealthServiceServer interface {
	mustEmbedUnimplementedHealthServiceServer()
}

func RegisterHealthServiceServer(s grpc.ServiceRegistrar, srv HealthServiceServer) {
	s.RegisterService(&HealthService_ServiceDesc, srv)
}

func _HealthService_GetTemperature_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTemperatureRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HealthServiceServer).GetTemperature(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bosdyn.api.spot_cam.HealthService/GetTemperature",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HealthServiceServer).GetTemperature(ctx, req.(*GetTemperatureRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HealthService_GetBITStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBITStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HealthServiceServer).GetBITStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bosdyn.api.spot_cam.HealthService/GetBITStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HealthServiceServer).GetBITStatus(ctx, req.(*GetBITStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HealthService_ClearBITEvents_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClearBITEventsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HealthServiceServer).ClearBITEvents(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bosdyn.api.spot_cam.HealthService/ClearBITEvents",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HealthServiceServer).ClearBITEvents(ctx, req.(*ClearBITEventsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HealthService_GetSystemLog_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetSystemLogRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(HealthServiceServer).GetSystemLog(m, &healthServiceGetSystemLogServer{stream})
}

type HealthService_GetSystemLogServer interface {
	Send(*GetSystemLogResponse) error
	grpc.ServerStream
}

type healthServiceGetSystemLogServer struct {
	grpc.ServerStream
}

func (x *healthServiceGetSystemLogServer) Send(m *GetSystemLogResponse) error {
	return x.ServerStream.SendMsg(m)
}

// HealthService_ServiceDesc is the grpc.ServiceDesc for HealthService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var HealthService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "bosdyn.api.spot_cam.HealthService",
	HandlerType: (*HealthServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetTemperature",
			Handler:    _HealthService_GetTemperature_Handler,
		},
		{
			MethodName: "GetBITStatus",
			Handler:    _HealthService_GetBITStatus_Handler,
		},
		{
			MethodName: "ClearBITEvents",
			Handler:    _HealthService_ClearBITEvents_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GetSystemLog",
			Handler:       _HealthService_GetSystemLog_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "bosdyn/api/spot_cam/service.proto",
}

// NetworkServiceClient is the client API for NetworkService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type NetworkServiceClient interface {
	//SetICEConfiguration sets up parameters for ICE, including addresses for STUN and TURN services
	SetICEConfiguration(ctx context.Context, in *SetICEConfigurationRequest, opts ...grpc.CallOption) (*SetICEConfigurationResponse, error)
	//GetICEConfiguration retrieves currently set parameters for ICE, including addresses for STUN and TURN services
	GetICEConfiguration(ctx context.Context, in *GetICEConfigurationRequest, opts ...grpc.CallOption) (*GetICEConfigurationResponse, error)
}

type networkServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewNetworkServiceClient(cc grpc.ClientConnInterface) NetworkServiceClient {
	return &networkServiceClient{cc}
}

func (c *networkServiceClient) SetICEConfiguration(ctx context.Context, in *SetICEConfigurationRequest, opts ...grpc.CallOption) (*SetICEConfigurationResponse, error) {
	out := new(SetICEConfigurationResponse)
	err := c.cc.Invoke(ctx, "/bosdyn.api.spot_cam.NetworkService/SetICEConfiguration", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *networkServiceClient) GetICEConfiguration(ctx context.Context, in *GetICEConfigurationRequest, opts ...grpc.CallOption) (*GetICEConfigurationResponse, error) {
	out := new(GetICEConfigurationResponse)
	err := c.cc.Invoke(ctx, "/bosdyn.api.spot_cam.NetworkService/GetICEConfiguration", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NetworkServiceServer is the server API for NetworkService service.
// All implementations must embed UnimplementedNetworkServiceServer
// for forward compatibility
type NetworkServiceServer interface {
	//SetICEConfiguration sets up parameters for ICE, including addresses for STUN and TURN services
	SetICEConfiguration(context.Context, *SetICEConfigurationRequest) (*SetICEConfigurationResponse, error)
	//GetICEConfiguration retrieves currently set parameters for ICE, including addresses for STUN and TURN services
	GetICEConfiguration(context.Context, *GetICEConfigurationRequest) (*GetICEConfigurationResponse, error)
	mustEmbedUnimplementedNetworkServiceServer()
}

// UnimplementedNetworkServiceServer must be embedded to have forward compatible implementations.
type UnimplementedNetworkServiceServer struct {
}

func (UnimplementedNetworkServiceServer) SetICEConfiguration(context.Context, *SetICEConfigurationRequest) (*SetICEConfigurationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetICEConfiguration not implemented")
}
func (UnimplementedNetworkServiceServer) GetICEConfiguration(context.Context, *GetICEConfigurationRequest) (*GetICEConfigurationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetICEConfiguration not implemented")
}
func (UnimplementedNetworkServiceServer) mustEmbedUnimplementedNetworkServiceServer() {}

// UnsafeNetworkServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to NetworkServiceServer will
// result in compilation errors.
type UnsafeNetworkServiceServer interface {
	mustEmbedUnimplementedNetworkServiceServer()
}

func RegisterNetworkServiceServer(s grpc.ServiceRegistrar, srv NetworkServiceServer) {
	s.RegisterService(&NetworkService_ServiceDesc, srv)
}

func _NetworkService_SetICEConfiguration_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetICEConfigurationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetworkServiceServer).SetICEConfiguration(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bosdyn.api.spot_cam.NetworkService/SetICEConfiguration",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetworkServiceServer).SetICEConfiguration(ctx, req.(*SetICEConfigurationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NetworkService_GetICEConfiguration_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetICEConfigurationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetworkServiceServer).GetICEConfiguration(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bosdyn.api.spot_cam.NetworkService/GetICEConfiguration",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetworkServiceServer).GetICEConfiguration(ctx, req.(*GetICEConfigurationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// NetworkService_ServiceDesc is the grpc.ServiceDesc for NetworkService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var NetworkService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "bosdyn.api.spot_cam.NetworkService",
	HandlerType: (*NetworkServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SetICEConfiguration",
			Handler:    _NetworkService_SetICEConfiguration_Handler,
		},
		{
			MethodName: "GetICEConfiguration",
			Handler:    _NetworkService_GetICEConfiguration_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "bosdyn/api/spot_cam/service.proto",
}

// VersionServiceClient is the client API for VersionService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type VersionServiceClient interface {
	GetSoftwareVersion(ctx context.Context, in *GetSoftwareVersionRequest, opts ...grpc.CallOption) (*GetSoftwareVersionResponse, error)
}

type versionServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewVersionServiceClient(cc grpc.ClientConnInterface) VersionServiceClient {
	return &versionServiceClient{cc}
}

func (c *versionServiceClient) GetSoftwareVersion(ctx context.Context, in *GetSoftwareVersionRequest, opts ...grpc.CallOption) (*GetSoftwareVersionResponse, error) {
	out := new(GetSoftwareVersionResponse)
	err := c.cc.Invoke(ctx, "/bosdyn.api.spot_cam.VersionService/GetSoftwareVersion", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// VersionServiceServer is the server API for VersionService service.
// All implementations must embed UnimplementedVersionServiceServer
// for forward compatibility
type VersionServiceServer interface {
	GetSoftwareVersion(context.Context, *GetSoftwareVersionRequest) (*GetSoftwareVersionResponse, error)
	mustEmbedUnimplementedVersionServiceServer()
}

// UnimplementedVersionServiceServer must be embedded to have forward compatible implementations.
type UnimplementedVersionServiceServer struct {
}

func (UnimplementedVersionServiceServer) GetSoftwareVersion(context.Context, *GetSoftwareVersionRequest) (*GetSoftwareVersionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSoftwareVersion not implemented")
}
func (UnimplementedVersionServiceServer) mustEmbedUnimplementedVersionServiceServer() {}

// UnsafeVersionServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to VersionServiceServer will
// result in compilation errors.
type UnsafeVersionServiceServer interface {
	mustEmbedUnimplementedVersionServiceServer()
}

func RegisterVersionServiceServer(s grpc.ServiceRegistrar, srv VersionServiceServer) {
	s.RegisterService(&VersionService_ServiceDesc, srv)
}

func _VersionService_GetSoftwareVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSoftwareVersionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VersionServiceServer).GetSoftwareVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bosdyn.api.spot_cam.VersionService/GetSoftwareVersion",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VersionServiceServer).GetSoftwareVersion(ctx, req.(*GetSoftwareVersionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// VersionService_ServiceDesc is the grpc.ServiceDesc for VersionService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var VersionService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "bosdyn.api.spot_cam.VersionService",
	HandlerType: (*VersionServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetSoftwareVersion",
			Handler:    _VersionService_GetSoftwareVersion_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "bosdyn/api/spot_cam/service.proto",
}
